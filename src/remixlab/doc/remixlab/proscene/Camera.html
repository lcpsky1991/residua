<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_33) on Sun Jul 01 14:37:24 GMT-03:00 2012 -->
<TITLE>
Camera
</TITLE>

<META NAME="date" CONTENT="2012-07-01">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Camera";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../remixlab/proscene/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../remixlab/proscene/Bindings.html" title="class in remixlab.proscene"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../remixlab/proscene/Camera.Cone.html" title="class in remixlab.proscene"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?remixlab/proscene/Camera.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Camera.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
remixlab.proscene</FONT>
<BR>
Class Camera</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>remixlab.proscene.Camera</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Cloneable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Camera</B><DT>extends java.lang.Object<DT>implements java.lang.Cloneable</DL>
</PRE>

<P>
A perspective or orthographic camera.
 <p>
 A Camera defines some intrinsic parameters (<A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A>,
 <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#viewDirection()"><CODE>viewDirection()</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#upVector()"><CODE>upVector()</CODE></A>...) and
 useful positioning tools that ease its placement (<A HREF="../../remixlab/proscene/Camera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A>,
 <A HREF="../../remixlab/proscene/Camera.html#fitSphere(PVector, float)"><CODE>fitSphere(PVector, float)</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#lookAt(PVector)"><CODE>lookAt(PVector)</CODE></A>...). It exports
 its associated processing projection and modelview matrices and it can
 interactively be modified using the mouse.
 <p>
 Camera matrices can be directly set as references to the processing camera
 matrices (default), or they can be set as independent PMatrix3D objects
 (which may be useful for off-screen computations). See
 <A HREF="../../remixlab/proscene/Camera.html#isAttachedToP5Camera()"><CODE>isAttachedToP5Camera()</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#attachToP5Camera()"><CODE>attachToP5Camera()</CODE></A> and
 <A HREF="../../remixlab/proscene/Camera.html#detachFromP5Camera()"><CODE>detachFromP5Camera()</CODE></A>.
 <p>
 There are to <A HREF="../../remixlab/proscene/Camera.html#kind()"><CODE>kind()</CODE></A> of Cameras: PROSCENE (default) and STANDARD. The
 former kind dynamically sets up the <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A>
 values, in order to provide optimal precision of the z-buffer. The latter
 kind provides fixed values to both of them (<A HREF="../../remixlab/proscene/Camera.html#setStandardZNear(float)"><CODE>setStandardZNear(float)</CODE></A>
 and <A HREF="../../remixlab/proscene/Camera.html#setStandardZFar(float)"><CODE>setStandardZFar(float)</CODE></A>).
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.Cone.html" title="class in remixlab.proscene">Camera.Cone</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Internal class that represents/holds a cone of normals.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.Kind.html" title="enum in remixlab.proscene">Camera.Kind</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enumerates the Camera kind.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.Type.html" title="enum in remixlab.proscene">Camera.Type</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enumerates the two possible types of Camera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.Visibility.html" title="enum in remixlab.proscene">Camera.Visibility</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enumerates the different visibility state an object may have respect to the
 camera frustum.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.WorldPoint.html" title="class in remixlab.proscene">Camera.WorldPoint</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Internal class provided to catch the output of
 <A HREF="../../remixlab/proscene/Camera.html#pointUnderPixel(remixlab.proscene.Point)"><CODE>pointUnderPixel(Point)</CODE></A> (which should be
 implemented by an openGL based derived class Camera).</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#fpCoefficients">fpCoefficients</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#fpCoefficientsUpdate">fpCoefficientsUpdate</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../remixlab/proscene/KeyFrameInterpolator.html" title="class in remixlab.proscene">KeyFrameInterpolator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#interpolationKfi">interpolationKfi</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.HashMap&lt;java.lang.Integer,<A HREF="../../remixlab/proscene/KeyFrameInterpolator.html" title="class in remixlab.proscene">KeyFrameInterpolator</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#kfi">kfi</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#lastFPCoeficientsUpdateIssued">lastFPCoeficientsUpdateIssued</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#lastFrameUpdate">lastFrameUpdate</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Which was the last frame the camera changes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PGraphicsOpenGL</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#pg3d">pg3d</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#projectCacheOptimized">projectCacheOptimized</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../remixlab/proscene/Scene.html" title="class in remixlab.proscene">Scene</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#scene">scene</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../remixlab/proscene/InteractiveCameraFrame.html" title="class in remixlab.proscene">InteractiveCameraFrame</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#tempFrame">tempFrame</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#unprojectCacheOptimized">unprojectCacheOptimized</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#Camera(remixlab.proscene.Scene)">Camera</A></B>(<A HREF="../../remixlab/proscene/Scene.html" title="class in remixlab.proscene">Scene</A>&nbsp;scn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience constructor that simply calls <code>this(true, scn)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#Camera(remixlab.proscene.Scene, boolean)">Camera</A></B>(<A HREF="../../remixlab/proscene/Scene.html" title="class in remixlab.proscene">Scene</A>&nbsp;scn,
       boolean&nbsp;attachedToScene)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Main constructor.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../remixlab/proscene/Camera.Visibility.html" title="enum in remixlab.proscene">Camera.Visibility</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#aaBoxIsVisible(PVector, PVector)">aaBoxIsVisible</A></B>(PVector&nbsp;p1,
               PVector&nbsp;p2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <A HREF="../../remixlab/proscene/Camera.Visibility.html#VISIBLE"><CODE>Camera.Visibility.VISIBLE</CODE></A>,
 <A HREF="../../remixlab/proscene/Camera.Visibility.html#INVISIBLE"><CODE>Camera.Visibility.INVISIBLE</CODE></A>, or
 <A HREF="../../remixlab/proscene/Camera.Visibility.html#SEMIVISIBLE"><CODE>Camera.Visibility.SEMIVISIBLE</CODE></A>, depending whether
 the axis aligned box (defined by corners <code>p1</code> and <code>p2</code>) is
 visible, invisible, or semi-visible, respectively.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#addKeyFrameToPath(int)">addKeyFrameToPath</A></B>(int&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply calls <code>addKeyFrameToPath(key, true)</code>
 .</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#addKeyFrameToPath(int, boolean)">addKeyFrameToPath</A></B>(int&nbsp;key,
                  boolean&nbsp;editablePath)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the current Camera <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A> as a
 keyFrame to path <code>key</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#anyInterpolationIsStarted()">anyInterpolationIsStarted</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if any interpolation associated with this Camera
 is currently being performed (and <code>false</code> otherwise).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#arcballReferencePoint()">arcballReferencePoint</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The point the Camera revolves around with the
 <A HREF="../../remixlab/proscene/Scene.MouseAction.html#ROTATE"><CODE>Scene.MouseAction.ROTATE</CODE></A> mouse binding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#aspectRatio()">aspectRatio</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Camera aspect ratio defined by <A HREF="../../remixlab/proscene/Camera.html#screenWidth()"><CODE>screenWidth()</CODE></A> /
 <A HREF="../../remixlab/proscene/Camera.html#screenHeight()"><CODE>screenHeight()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#at()">at</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a point defined in the world coordinate system where the camera is
 pointing at (just in front of <A HREF="../../remixlab/proscene/Camera.html#viewDirection()"><CODE>viewDirection()</CODE></A>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#attachToP5Camera()">attachToP5Camera</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the Camera matrices as references to the processing camera matrices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#cacheMatrices()">cacheMatrices</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cache <code>(P x M)</code> and <code>inv (P x M)</code> under the following circumstances:</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#cameraCoordinatesOf(PVector)">cameraCoordinatesOf</A></B>(PVector&nbsp;src)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Camera frame coordinates of a point <code>src</code> defined in
 world coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#centerScene()">centerScene</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the Camera so that its <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> is projected on the
 center of the window.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#changeStandardOrthoFrustumSize(boolean)">changeStandardOrthoFrustumSize</A></B>(boolean&nbsp;augment)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the size of the frustum.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../remixlab/proscene/Camera.html" title="class in remixlab.proscene">Camera</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#clone()">clone</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of the clone method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()">computeFrustumEquations</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply returns <code>computeFrustumPlanesCoefficients(new float [6][4])</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations(float[][])">computeFrustumEquations</A></B>(float[][]&nbsp;coef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills <code>coef</code> with the 6 plane equations of the camera frustum and
 returns it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#computeModelViewMatrix()">computeModelViewMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the modelView matrix associated with the Camera's
 <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#computeProjectionMatrix()">computeProjectionMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the projection matrix associated with the Camera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(java.util.ArrayList)">coneIsBackFacing</A></B>(java.util.ArrayList&lt;PVector&gt;&nbsp;normals)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply calls <code>coneIsBackFacing(new Cone(normals))</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(remixlab.proscene.Camera.Cone)">coneIsBackFacing</A></B>(<A HREF="../../remixlab/proscene/Camera.Cone.html" title="class in remixlab.proscene">Camera.Cone</A>&nbsp;cone)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply returns <code>coneIsBackFacing(cone.axis(), cone.angle())</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(PVector[])">coneIsBackFacing</A></B>(PVector[]&nbsp;normals)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply calls <code>coneIsBackFacing(new Cone(normals))</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(PVector, java.util.ArrayList)">coneIsBackFacing</A></B>(PVector&nbsp;viewDirection,
                 java.util.ArrayList&lt;PVector&gt;&nbsp;normals)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply calls
 {coneIsBackFacing(viewDirection, new Cone(normals))}.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(PVector, remixlab.proscene.Camera.Cone)">coneIsBackFacing</A></B>(PVector&nbsp;viewDirection,
                 <A HREF="../../remixlab/proscene/Camera.Cone.html" title="class in remixlab.proscene">Camera.Cone</A>&nbsp;cone)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply returns 
 <code>coneIsBackFacing(viewDirection, cone.axis(), cone.angle())</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(PVector, float)">coneIsBackFacing</A></B>(PVector&nbsp;axis,
                 float&nbsp;angle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convinience funtion that simply returns
 <code>coneIsBackFacing(viewDirection(), axis, angle)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(PVector, PVector[])">coneIsBackFacing</A></B>(PVector&nbsp;viewDirection,
                 PVector[]&nbsp;normals)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply returns
 <code>coneIsBackFacing(viewDirection, new Cone(normals))</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(PVector, PVector, float)">coneIsBackFacing</A></B>(PVector&nbsp;viewDirection,
                 PVector&nbsp;axis,
                 float&nbsp;angle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the given cone is back facing the camera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#convertClickToLine(remixlab.proscene.Point, PVector, PVector)">convertClickToLine</A></B>(<A HREF="../../remixlab/proscene/Point.html" title="class in remixlab.proscene">Point</A>&nbsp;pixelInput,
                   PVector&nbsp;orig,
                   PVector&nbsp;dir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gives the coefficients of a 3D half-line passing through the Camera eye and
 pixel (x,y).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#deletePath(int)">deletePath</A></B>(int&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deletes the <A HREF="../../remixlab/proscene/Camera.html#keyFrameInterpolator(int)"><CODE>keyFrameInterpolator(int)</CODE></A> of index <code>key</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#detachFromP5Camera()">detachFromP5Camera</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create new independent Camera matrices' objects (i.e., Camera matrices are
 no longer set as references to processing camera matrices).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#distanceToFrustumPlane(int, PVector)">distanceToFrustumPlane</A></B>(int&nbsp;index,
                       PVector&nbsp;pos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the signed distance between point <code>pos</code> and plane <code>index</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#distanceToSceneCenter()">distanceToSceneCenter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the distance from the Camera center to <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>,
 projected along the Camera Z axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#drawAllPaths()">drawAllPaths</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws all the Camera paths defined by <A HREF="../../remixlab/proscene/Camera.html#keyFrameInterpolator(int)"><CODE>keyFrameInterpolator(int)</CODE></A>
 and makes them editable by adding all its Frames to the mouse grabber pool.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#enableFrustumEquationsUpdate(boolean)">enableFrustumEquationsUpdate</A></B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables or disables automatic update of the camera frustum plane equations
 every frame according to <code>flag</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#faceIsBackFacing(PVector, PVector, PVector)">faceIsBackFacing</A></B>(PVector&nbsp;a,
                 PVector&nbsp;b,
                 PVector&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the given face is back facing the camera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#fieldOfView()">fieldOfView</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the vertical field of view of the Camera (in radians).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#fitBoundingBox(PVector, PVector)">fitBoundingBox</A></B>(PVector&nbsp;min,
               PVector&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the Camera so that the (world axis aligned) bounding box (<code>min</code>
 , <code>max</code>) is entirely visible, using
 <A HREF="../../remixlab/proscene/Camera.html#fitSphere(PVector, float)"><CODE>fitSphere(PVector, float)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#fitScreenRegion(remixlab.proscene.Rectangle)">fitScreenRegion</A></B>(<A HREF="../../remixlab/proscene/Rectangle.html" title="class in remixlab.proscene">Rectangle</A>&nbsp;rectangle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the Camera so that the rectangular screen region defined by <code>rectangle</code> (pixel units, with origin in the upper left corner) fits the
 screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#fitSphere(PVector, float)">fitSphere</A></B>(PVector&nbsp;center,
          float&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the Camera so that the sphere defined by <code>center</code> and <code>radius</code> is visible and fits the window.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#flySpeed()">flySpeed</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the fly speed of the Camera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#focusDistance()">focusDistance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the focus distance used by stereo display, expressed in processing
 units.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../remixlab/proscene/InteractiveCameraFrame.html" title="class in remixlab.proscene">InteractiveCameraFrame</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#frame()">frame</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the InteractiveCameraFrame attached to the Camera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#frustumEquationsUpdateIsEnable()">frustumEquationsUpdateIsEnable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if automatic update of the camera frustum plane
 equations is enabled and <code>false</code> otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#getFrustumEquations()">getFrustumEquations</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the frustum plane equations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PMatrix3D</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#getModelViewMatrix()">getModelViewMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply returns <code>getModelViewMatrix(new
 PMatrix3D())</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PMatrix3D</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#getModelViewMatrix(PMatrix3D)">getModelViewMatrix</A></B>(PMatrix3D&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills <code>m</code> with the Camera modelView matrix values and returns it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#getOrthoWidthHeight()">getOrthoWidthHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply returns <code>getOrthoWidthHeight(new
 float[2])</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#getOrthoWidthHeight(float[])">getOrthoWidthHeight</A></B>(float[]&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills in <code>target</code> with the <code>halfWidth</code> and <code>halfHeight</code>
 of the Camera orthographic frustum and returns it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PMatrix3D</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#getProjectionMatrix()">getProjectionMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply returns <code>getProjectionMatrix(new
 PMatrix3D())</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PMatrix3D</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#getProjectionMatrix(PMatrix3D)">getProjectionMatrix</A></B>(PMatrix3D&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills <code>m</code> with the Camera projection matrix values and returns it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#getViewport()">getViewport</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply calls <code>return</code>
 <A HREF="../../remixlab/proscene/Camera.html#getViewport(int[])"><CODE>getViewport(int[])</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#getViewport(int[])">getViewport</A></B>(int[]&nbsp;viewport)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills <code>viewport</code> with the Camera viewport and returns it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#hideAllPaths()">hideAllPaths</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hides all the Camera paths defined by <A HREF="../../remixlab/proscene/Camera.html#keyFrameInterpolator(int)"><CODE>keyFrameInterpolator(int)</CODE></A> by
 provisionally removing all its Frames from the mouse grabber pool.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#horizontalFieldOfView()">horizontalFieldOfView</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the horizontal field of view of the Camera (in radians).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#interpolateTo(remixlab.proscene.Frame)">interpolateTo</A></B>(<A HREF="../../remixlab/proscene/Frame.html" title="class in remixlab.proscene">Frame</A>&nbsp;fr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply calls <code>interpolateTo(fr, 1)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#interpolateTo(remixlab.proscene.Frame, float)">interpolateTo</A></B>(<A HREF="../../remixlab/proscene/Frame.html" title="class in remixlab.proscene">Frame</A>&nbsp;fr,
              float&nbsp;duration)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Smoothly interpolates the Camera on a KeyFrameInterpolator path so that it
 goes to <code>fr</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#interpolateToFitScene()">interpolateToFitScene</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interpolates the Camera on a one second KeyFrameInterpolator path so that
 the entire scene fits the screen at the end.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../remixlab/proscene/Camera.WorldPoint.html" title="class in remixlab.proscene">Camera.WorldPoint</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#interpolateToZoomOnPixel(remixlab.proscene.Point)">interpolateToZoomOnPixel</A></B>(<A HREF="../../remixlab/proscene/Point.html" title="class in remixlab.proscene">Point</A>&nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Makes the Camera smoothly zoom on the <A HREF="../../remixlab/proscene/Camera.html#pointUnderPixel(remixlab.proscene.Point)"><CODE>pointUnderPixel(Point)</CODE></A>
 <code>pixel</code> and returns the world coordinates of the
 <A HREF="../../remixlab/proscene/Camera.html#pointUnderPixel(remixlab.proscene.Point)"><CODE>pointUnderPixel(Point)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#interpolateToZoomOnRegion(remixlab.proscene.Rectangle)">interpolateToZoomOnRegion</A></B>(<A HREF="../../remixlab/proscene/Rectangle.html" title="class in remixlab.proscene">Rectangle</A>&nbsp;rectangle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Smoothly moves the Camera so that the rectangular screen region defined by
 <code>rectangle</code> (pixel units, with origin in the upper left corner) fits
 the screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#IODistance()">IODistance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the user's inter-ocular distance (in meters).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#isAttachedToP5Camera()">isAttachedToP5Camera</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the Camera matrices are set as references to the
 processing camera matrices and <code>false</code> if not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#isDetachedFromP5Camera()">isDetachedFromP5Camera</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply returns <code>!isAttachedToScene()</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../remixlab/proscene/KeyFrameInterpolator.html" title="class in remixlab.proscene">KeyFrameInterpolator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#keyFrameInterpolator(int)">keyFrameInterpolator</A></B>(int&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the KeyFrameInterpolator that defines the Camera path number
 <code>key</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../remixlab/proscene/Camera.Kind.html" title="enum in remixlab.proscene">Camera.Kind</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#kind()">kind</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the kind of the Camera: PROSCENE or STANDARD.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#lookAt(PVector)">lookAt</A></B>(PVector&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the Camera <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A>, so that it looks at point <code>target</code> (defined in the world coordinate system).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#optimizeUnprojectCache(boolean)">optimizeUnprojectCache</A></B>(boolean&nbsp;optimise)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cache <code>inv (P x M)</code> (and also <code>(P x M)</code> ) so that
 <A HREF="../../remixlab/proscene/Camera.html#project(float, float, float, PMatrix3D, PMatrix3D, int[], float[])"><CODE>project(float, float, float, PMatrix3D, PMatrix3D, int[], float[])</CODE></A>
 (and also <A HREF="../../remixlab/proscene/Camera.html#unproject(float, float, float, PMatrix3D, PMatrix3D, int[], float[])"><CODE>unproject(float, float, float, PMatrix3D, PMatrix3D, int[], float[])</CODE></A>)
 is optimised.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../remixlab/proscene/Quaternion.html" title="class in remixlab.proscene">Quaternion</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#orientation()">orientation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Camera orientation, defined in the world coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#physicalDistanceToScreen()">physicalDistanceToScreen</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the physical distance between the user's eyes and the screen (in
 meters).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#physicalScreenWidth()">physicalScreenWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the physical screen width, in meters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#pixelP5Ratio(PVector)">pixelP5Ratio</A></B>(PVector&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the ratio between pixel and processing scene units at <code>position</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#playPath(int)">playPath</A></B>(int&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Makes the Camera follow the path of keyFrameInterpolator() number <code>key</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#pointIsVisible(PVector)">pointIsVisible</A></B>(PVector&nbsp;point)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if <code>point</code> is visible (i.e, lies within the
 frustum) and <code>false</code> otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../remixlab/proscene/Camera.WorldPoint.html" title="class in remixlab.proscene">Camera.WorldPoint</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#pointUnderPixel(remixlab.proscene.Point)">pointUnderPixel</A></B>(<A HREF="../../remixlab/proscene/Point.html" title="class in remixlab.proscene">Point</A>&nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the coordinates of the 3D point located at <code>pixel</code> (x,y) on
 screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#position()">position</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Camera position (the eye), defined in the world coordinate
 system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#project(float, float, float, PMatrix3D, PMatrix3D, int[], float[])">project</A></B>(float&nbsp;objx,
        float&nbsp;objy,
        float&nbsp;objz,
        PMatrix3D&nbsp;modelview,
        PMatrix3D&nbsp;projection,
        int[]&nbsp;viewport,
        float[]&nbsp;windowCoordinate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similar to <code>gluProject</code>: map object coordinates to window
 coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#projectedCoordinatesOf(PVector)">projectedCoordinatesOf</A></B>(PVector&nbsp;src)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply returns <code>projectedCoordinatesOf(src,
 null)</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#projectedCoordinatesOf(PVector, remixlab.proscene.Frame)">projectedCoordinatesOf</A></B>(PVector&nbsp;src,
                       <A HREF="../../remixlab/proscene/Frame.html" title="class in remixlab.proscene">Frame</A>&nbsp;frame)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the screen projected coordinates of a point <code>src</code> defined in
 the <code>frame</code> coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#resetPath(int)">resetPath</A></B>(int&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resets the path of the <A HREF="../../remixlab/proscene/Camera.html#keyFrameInterpolator(int)"><CODE>keyFrameInterpolator(int)</CODE></A> number <code>key</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#rightVector()">rightVector</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the normalized right vector of the Camera, defined in the world
 coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#rotationSensitivity()">rotationSensitivity</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience wrapper function that simply returns <code>frame().rotationSensitivity()</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#sceneCenter()">sceneCenter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the position of the scene center, defined in the world coordinate
 system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#sceneRadius()">sceneRadius</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the radius of the scene observed by the Camera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#screenHeight()">screenHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the height (in pixels) of the Camera screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#screenWidth()">screenWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the width (in pixels) of the Camera screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setArcballReferencePoint(PVector)">setArcballReferencePoint</A></B>(PVector&nbsp;rap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the <A HREF="../../remixlab/proscene/Camera.html#arcballReferencePoint()"><CODE>arcballReferencePoint()</CODE></A> to <code>rap</code> (defined in the
 world coordinate system).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setArcballReferencePointFromPixel(remixlab.proscene.Point)">setArcballReferencePointFromPixel</A></B>(<A HREF="../../remixlab/proscene/Point.html" title="class in remixlab.proscene">Point</A>&nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <A HREF="../../remixlab/proscene/Camera.html#arcballReferencePoint()"><CODE>arcballReferencePoint()</CODE></A> is set to the point located under
 <code>pixel</code> on screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setAspectRatio(float)">setAspectRatio</A></B>(float&nbsp;aspect)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines the Camera <A HREF="../../remixlab/proscene/Camera.html#aspectRatio()"><CODE>aspectRatio()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setFieldOfView(float)">setFieldOfView</A></B>(float&nbsp;fov)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the vertical <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> of the Camera (in radians).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setFlySpeed(float)">setFlySpeed</A></B>(float&nbsp;speed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the Camera <A HREF="../../remixlab/proscene/Camera.html#flySpeed()"><CODE>flySpeed()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setFocusDistance(float)">setFocusDistance</A></B>(float&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the focusDistance(), in processing scene units.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setFOVToFitScene()">setFOVToFitScene</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the Camera <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> so that the entire scene (defined
 by <A HREF="../../remixlab/proscene/Scene.html#center()"><CODE>Scene.center()</CODE></A> and
 <A HREF="../../remixlab/proscene/Scene.html#radius()"><CODE>Scene.radius()</CODE></A> is visible from the Camera
 <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setFrame(remixlab.proscene.InteractiveCameraFrame)">setFrame</A></B>(<A HREF="../../remixlab/proscene/InteractiveCameraFrame.html" title="class in remixlab.proscene">InteractiveCameraFrame</A>&nbsp;icf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the Camera <A HREF="../../remixlab/proscene/Camera.html#frame()"><CODE>frame()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setHorizontalFieldOfView(float)">setHorizontalFieldOfView</A></B>(float&nbsp;hfov)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../../remixlab/proscene/Camera.html#horizontalFieldOfView()"><CODE>horizontalFieldOfView()</CODE></A> of the Camera (in radians).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setIODistance(float)">setIODistance</A></B>(float&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../../remixlab/proscene/Camera.html#IODistance()"><CODE>IODistance()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setKeyFrameInterpolator(int, remixlab.proscene.KeyFrameInterpolator)">setKeyFrameInterpolator</A></B>(int&nbsp;key,
                        <A HREF="../../remixlab/proscene/KeyFrameInterpolator.html" title="class in remixlab.proscene">KeyFrameInterpolator</A>&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the KeyFrameInterpolator that defines the Camera path of index <code>key</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setKind(remixlab.proscene.Camera.Kind)">setKind</A></B>(<A HREF="../../remixlab/proscene/Camera.Kind.html" title="enum in remixlab.proscene">Camera.Kind</A>&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the kind of the Camera: PROSCENE or STANDARD.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setModelViewMatrix(PMatrix3D)">setModelViewMatrix</A></B>(PMatrix3D&nbsp;modelview)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills the modelview matrix with the <code>modelview</code> matrix values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setOrientation(float, float)">setOrientation</A></B>(float&nbsp;theta,
               float&nbsp;phi)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A> of the Camera using polar coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setOrientation(remixlab.proscene.Quaternion)">setOrientation</A></B>(<A HREF="../../remixlab/proscene/Quaternion.html" title="class in remixlab.proscene">Quaternion</A>&nbsp;q)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the Camera <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A>, defined in the world coordinate
 system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setPhysicalDistanceToScreen(float)">setPhysicalDistanceToScreen</A></B>(float&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../../remixlab/proscene/Camera.html#physicalDistanceToScreen()"><CODE>physicalDistanceToScreen()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setPhysicalScreenWidth(float)">setPhysicalScreenWidth</A></B>(float&nbsp;width)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the physical screen (monitor or projected wall) width (in meters).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setPosition(PVector)">setPosition</A></B>(PVector&nbsp;pos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the Camera <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A> (the eye), defined in the world
 coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setProjectionMatrix(PMatrix3D)">setProjectionMatrix</A></B>(PMatrix3D&nbsp;proj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills the projection matrix with the <code>proj</code> matrix values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setRotationSensitivity(float)">setRotationSensitivity</A></B>(float&nbsp;sensitivity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience wrapper function that simply calls <code>frame().setRotationSensitivity(sensitivity)</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setSceneBoundingBox(PVector, PVector)">setSceneBoundingBox</A></B>(PVector&nbsp;min,
                    PVector&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similar to <A HREF="../../remixlab/proscene/Camera.html#setSceneRadius(float)"><CODE>setSceneRadius(float)</CODE></A> and
 <A HREF="../../remixlab/proscene/Camera.html#setSceneCenter(PVector)"><CODE>setSceneCenter(PVector)</CODE></A>, but the scene limits are defined by a
 (world axis aligned) bounding box.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setSceneCenter(PVector)">setSceneCenter</A></B>(PVector&nbsp;center)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setSceneCenterFromPixel(remixlab.proscene.Point)">setSceneCenterFromPixel</A></B>(<A HREF="../../remixlab/proscene/Point.html" title="class in remixlab.proscene">Point</A>&nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <A HREF="../../remixlab/proscene/Camera.html#setSceneCenter(PVector)"><CODE>setSceneCenter(PVector)</CODE></A> is set to the point located under
 <code>pixel</code> on screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setSceneRadius(float)">setSceneRadius</A></B>(float&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setScreenWidthAndHeight(int, int)">setScreenWidthAndHeight</A></B>(int&nbsp;width,
                        int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets Camera <A HREF="../../remixlab/proscene/Camera.html#screenWidth()"><CODE>screenWidth()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#screenHeight()"><CODE>screenHeight()</CODE></A> (expressed
 in pixels).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setSpinningSensitivity(float)">setSpinningSensitivity</A></B>(float&nbsp;sensitivity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience wrapper function that simply calls <code>frame().setSpinningSensitivity(sensitivity)</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setStandardZFar(float)">setStandardZFar</A></B>(float&nbsp;zF)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the value of the <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setStandardZNear(float)">setStandardZNear</A></B>(float&nbsp;zN)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the value of the <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setTranslationSensitivity(float)">setTranslationSensitivity</A></B>(float&nbsp;sensitivity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience wrapper function that simply calls <code>frame().setTranslationSensitivity(sensitivity)</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setType(remixlab.proscene.Camera.Type)">setType</A></B>(<A HREF="../../remixlab/proscene/Camera.Type.html" title="enum in remixlab.proscene">Camera.Type</A>&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines the Camera <A HREF="../../remixlab/proscene/Camera.html#type()"><CODE>type()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setUpVector(PVector)">setUpVector</A></B>(PVector&nbsp;up)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply calls <code>setUpVector(up, true)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setUpVector(PVector, boolean)">setUpVector</A></B>(PVector&nbsp;up,
            boolean&nbsp;noMove)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the Camera so that its <A HREF="../../remixlab/proscene/Camera.html#upVector()"><CODE>upVector()</CODE></A> becomes <code>up</code>
 (defined in the world coordinate system).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setViewDirection(PVector)">setViewDirection</A></B>(PVector&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the Camera so that its <A HREF="../../remixlab/proscene/Camera.html#viewDirection()"><CODE>viewDirection()</CODE></A> is <code>direction</code> (defined in the world coordinate system).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setZClippingCoefficient(float)">setZClippingCoefficient</A></B>(float&nbsp;coef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../../remixlab/proscene/Camera.html#zClippingCoefficient()"><CODE>zClippingCoefficient()</CODE></A> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#setZNearCoefficient(float)">setZNearCoefficient</A></B>(float&nbsp;coef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../../remixlab/proscene/Camera.html#zNearCoefficient()"><CODE>zNearCoefficient()</CODE></A> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#showEntireScene()">showEntireScene</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the Camera so that the entire scene is visible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../remixlab/proscene/Camera.Visibility.html" title="enum in remixlab.proscene">Camera.Visibility</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#sphereIsVisible(PVector, float)">sphereIsVisible</A></B>(PVector&nbsp;center,
                float&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <A HREF="../../remixlab/proscene/Camera.Visibility.html#VISIBLE"><CODE>Camera.Visibility.VISIBLE</CODE></A>,
 <A HREF="../../remixlab/proscene/Camera.Visibility.html#INVISIBLE"><CODE>Camera.Visibility.INVISIBLE</CODE></A>, or
 <A HREF="../../remixlab/proscene/Camera.Visibility.html#SEMIVISIBLE"><CODE>Camera.Visibility.SEMIVISIBLE</CODE></A>, depending whether
 the sphere (of radius <code>radius</code> and center <code>center</code>) is visible,
 invisible, or semi-visible, respectively.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#spinningSensitivity()">spinningSensitivity</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience wrapper function that simply returns <code>frame().spinningSensitivity()</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#standardOrthoFrustumSize()">standardOrthoFrustumSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the frustum size.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#standardZFar()">standardZFar</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the value of the <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#standardZNear()">standardZNear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the value of the <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#stopAllInterpolations()">stopAllInterpolations</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stops all interpolations currently being performed
 associated with this Camera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#translationSensitivity()">translationSensitivity</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience wrapper function that simply returns <code>frame().translationSensitivity()</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../remixlab/proscene/Camera.Type.html" title="enum in remixlab.proscene">Camera.Type</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#type()">type</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Camera.Type of the Camera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#unproject(float, float, float, PMatrix3D, PMatrix3D, int[], float[])">unproject</A></B>(float&nbsp;winx,
          float&nbsp;winy,
          float&nbsp;winz,
          PMatrix3D&nbsp;modelview,
          PMatrix3D&nbsp;projection,
          int[]&nbsp;viewport,
          float[]&nbsp;objCoordinate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similar to <code>gluUnProject</code>: map window coordinates to object
 coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#unprojectCacheIsOptimized()">unprojectCacheIsOptimized</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if <code>P x M</code> and <code>inv (P x M)</code> are being cached,
 and <code>false</code> otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#unprojectedCoordinatesOf(PVector)">unprojectedCoordinatesOf</A></B>(PVector&nbsp;src)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply returns <code>return
 unprojectedCoordinatesOf(src, null)</code>
 
 #see <A HREF="../../remixlab/proscene/Camera.html#unprojectedCoordinatesOf(PVector, remixlab.proscene.Frame)"><CODE>unprojectedCoordinatesOf(PVector, Frame)</CODE></A></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#unprojectedCoordinatesOf(PVector, remixlab.proscene.Frame)">unprojectedCoordinatesOf</A></B>(PVector&nbsp;src,
                         <A HREF="../../remixlab/proscene/Frame.html" title="class in remixlab.proscene">Frame</A>&nbsp;frame)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the world unprojected coordinates of a point <code>src</code> defined in
 the screen coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#updateFrustumEquations()">updateFrustumEquations</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updates the frustum plane equations according to the current camera setup /
 <A HREF="../../remixlab/proscene/Camera.html#type()"><CODE>type()</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A>,
 <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A>, and <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A> values), by simply calling
 <A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()"><CODE>computeFrustumEquations()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#upVector()">upVector</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the normalized up vector of the Camera, defined in the world
 coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#viewDirection()">viewDirection</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the normalized view direction of the Camera, defined in the world
 coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#worldCoordinatesOf(PVector)">worldCoordinatesOf</A></B>(PVector&nbsp;src)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the world coordinates of the point whose position <code>src</code> is
 defined in the Camera coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#zClippingCoefficient()">zClippingCoefficient</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the coefficient used to position the near and far clipping planes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#zFar()">zFar</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the far clipping plane distance used by the Camera projection
 matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#zNear()">zNear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the near clipping plane distance used by the Camera projection
 matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../remixlab/proscene/Camera.html#zNearCoefficient()">zNearCoefficient</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the coefficient which is used to set <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A> when the
 Camera is inside the sphere defined by <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> and
 <A HREF="../../remixlab/proscene/Camera.html#zClippingCoefficient()"><CODE>zClippingCoefficient()</CODE></A> * <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="projectCacheOptimized"><!-- --></A><H3>
projectCacheOptimized</H3>
<PRE>
public boolean <B>projectCacheOptimized</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="unprojectCacheOptimized"><!-- --></A><H3>
unprojectCacheOptimized</H3>
<PRE>
public boolean <B>unprojectCacheOptimized</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="kfi"><!-- --></A><H3>
kfi</H3>
<PRE>
protected java.util.HashMap&lt;java.lang.Integer,<A HREF="../../remixlab/proscene/KeyFrameInterpolator.html" title="class in remixlab.proscene">KeyFrameInterpolator</A>&gt; <B>kfi</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="interpolationKfi"><!-- --></A><H3>
interpolationKfi</H3>
<PRE>
protected <A HREF="../../remixlab/proscene/KeyFrameInterpolator.html" title="class in remixlab.proscene">KeyFrameInterpolator</A> <B>interpolationKfi</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="tempFrame"><!-- --></A><H3>
tempFrame</H3>
<PRE>
protected <A HREF="../../remixlab/proscene/InteractiveCameraFrame.html" title="class in remixlab.proscene">InteractiveCameraFrame</A> <B>tempFrame</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fpCoefficients"><!-- --></A><H3>
fpCoefficients</H3>
<PRE>
protected float[][] <B>fpCoefficients</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="fpCoefficientsUpdate"><!-- --></A><H3>
fpCoefficientsUpdate</H3>
<PRE>
protected boolean <B>fpCoefficientsUpdate</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="lastFrameUpdate"><!-- --></A><H3>
lastFrameUpdate</H3>
<PRE>
public int <B>lastFrameUpdate</B></PRE>
<DL>
<DD>Which was the last frame the camera changes.
 <P>
 Takes into account the <A HREF="../../remixlab/proscene/Camera.html#frame()"><CODE>frame()</CODE></A> (position and orientation of the camera)
 and the camera <A HREF="../../remixlab/proscene/Camera.html#type()"><CODE>type()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#kind()"><CODE>kind()</CODE></A>.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="lastFPCoeficientsUpdateIssued"><!-- --></A><H3>
lastFPCoeficientsUpdateIssued</H3>
<PRE>
protected int <B>lastFPCoeficientsUpdateIssued</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="scene"><!-- --></A><H3>
scene</H3>
<PRE>
public <A HREF="../../remixlab/proscene/Scene.html" title="class in remixlab.proscene">Scene</A> <B>scene</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="pg3d"><!-- --></A><H3>
pg3d</H3>
<PRE>
public PGraphicsOpenGL <B>pg3d</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Camera(remixlab.proscene.Scene)"><!-- --></A><H3>
Camera</H3>
<PRE>
public <B>Camera</B>(<A HREF="../../remixlab/proscene/Scene.html" title="class in remixlab.proscene">Scene</A>&nbsp;scn)</PRE>
<DL>
<DD>Convenience constructor that simply calls <code>this(true, scn)</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#Camera(remixlab.proscene.Scene, boolean)"><CODE>Camera(Scene, boolean)</CODE></A></DL>
</DL>
<HR>

<A NAME="Camera(remixlab.proscene.Scene, boolean)"><!-- --></A><H3>
Camera</H3>
<PRE>
public <B>Camera</B>(<A HREF="../../remixlab/proscene/Scene.html" title="class in remixlab.proscene">Scene</A>&nbsp;scn,
              boolean&nbsp;attachedToScene)</PRE>
<DL>
<DD>Main constructor. <code>p</code> will be used for rendering purposes.
 <p>
 <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> is set to (0,0,0) and <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> is set
 to 100. <A HREF="../../remixlab/proscene/Camera.html#type()"><CODE>type()</CODE></A> Camera.PERSPECTIVE, with a <code>PI/4</code>
 <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A>.
 <p>
 If <code>attachedToScene</code> is true then the Camera matrices are set as
 references to the processing camera matrices. Otherwise newly matrices are
 created. In both cases the matrices are computed according to remaining
 default Camera parameters.
 <p>
 See <A HREF="../../remixlab/proscene/Camera.html#IODistance()"><CODE>IODistance()</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#physicalDistanceToScreen()"><CODE>physicalDistanceToScreen()</CODE></A>,
 <A HREF="../../remixlab/proscene/Camera.html#physicalScreenWidth()"><CODE>physicalScreenWidth()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#focusDistance()"><CODE>focusDistance()</CODE></A> documentations
 for default stereo parameter values.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#Camera(remixlab.proscene.Scene)"><CODE>Camera(Scene)</CODE></A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="isDetachedFromP5Camera()"><!-- --></A><H3>
isDetachedFromP5Camera</H3>
<PRE>
public boolean <B>isDetachedFromP5Camera</B>()</PRE>
<DL>
<DD>Convenience function that simply returns <code>!isAttachedToScene()</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#isAttachedToP5Camera()"><CODE>isAttachedToP5Camera()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isAttachedToP5Camera()"><!-- --></A><H3>
isAttachedToP5Camera</H3>
<PRE>
public boolean <B>isAttachedToP5Camera</B>()</PRE>
<DL>
<DD>Returns <code>true</code> if the Camera matrices are set as references to the
 processing camera matrices and <code>false</code> if not.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#isDetachedFromP5Camera()"><CODE>isDetachedFromP5Camera()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="attachToP5Camera()"><!-- --></A><H3>
attachToP5Camera</H3>
<PRE>
public void <B>attachToP5Camera</B>()</PRE>
<DL>
<DD>Set the Camera matrices as references to the processing camera matrices. If
 the references are already set (<A HREF="../../remixlab/proscene/Camera.html#isAttachedToP5Camera()"><CODE>isAttachedToP5Camera()</CODE></A>), silently
 ignores the call.
 <p>
 <b>Note:</b> Since it is only one Scene per PApplet, there's no need to
 specify it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#detachFromP5Camera()"><CODE>detachFromP5Camera()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#isAttachedToP5Camera()"><CODE>isAttachedToP5Camera()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="detachFromP5Camera()"><!-- --></A><H3>
detachFromP5Camera</H3>
<PRE>
public void <B>detachFromP5Camera</B>()</PRE>
<DL>
<DD>Create new independent Camera matrices' objects (i.e., Camera matrices are
 no longer set as references to processing camera matrices). If the Camera
 is already detached, silently ignores the call.
 <p>
 The values of the newly created matrices are set with
 <A HREF="../../remixlab/proscene/Camera.html#computeProjectionMatrix()"><CODE>computeProjectionMatrix()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#computeModelViewMatrix()"><CODE>computeModelViewMatrix()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#attachToP5Camera()"><CODE>attachToP5Camera()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#isAttachedToP5Camera()"><CODE>isAttachedToP5Camera()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="clone()"><!-- --></A><H3>
clone</H3>
<PRE>
public <A HREF="../../remixlab/proscene/Camera.html" title="class in remixlab.proscene">Camera</A> <B>clone</B>()</PRE>
<DL>
<DD>Implementation of the clone method.
 <p>
 Calls <A HREF="../../remixlab/proscene/Frame.html#clone()"><CODE>Frame.clone()</CODE></A> and makes a deep copy of the
 remaining object attributes except for <code>prevConstraint</code> (which is
 shallow copied).
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>clone</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Frame.html#clone()"><CODE>Frame.clone()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="position()"><!-- --></A><H3>
position</H3>
<PRE>
public final PVector <B>position</B>()</PRE>
<DL>
<DD>Returns the Camera position (the eye), defined in the world coordinate
 system.
 <p>
 Use <A HREF="../../remixlab/proscene/Camera.html#setPosition(PVector)"><CODE>setPosition(PVector)</CODE></A> to set the Camera position. Other
 convenient methods are showEntireScene() or fitSphere(). Actually returns
 <A HREF="../../remixlab/proscene/Frame.html#position()"><CODE>Frame.position()</CODE></A>.
 <p>
 This position corresponds to the projection center of a Camera.PERSPECTIVE
 camera. It is not located in the image plane, which is at a zNear()
 distance ahead.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setPosition(PVector)"><!-- --></A><H3>
setPosition</H3>
<PRE>
public void <B>setPosition</B>(PVector&nbsp;pos)</PRE>
<DL>
<DD>Sets the Camera <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A> (the eye), defined in the world
 coordinate system.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="upVector()"><!-- --></A><H3>
upVector</H3>
<PRE>
public PVector <B>upVector</B>()</PRE>
<DL>
<DD>Returns the normalized up vector of the Camera, defined in the world
 coordinate system.
 <p>
 Set using <A HREF="../../remixlab/proscene/Camera.html#setUpVector(PVector)"><CODE>setUpVector(PVector)</CODE></A> or
 <A HREF="../../remixlab/proscene/Camera.html#setOrientation(remixlab.proscene.Quaternion)"><CODE>setOrientation(Quaternion)</CODE></A>. It is orthogonal to
 <A HREF="../../remixlab/proscene/Camera.html#viewDirection()"><CODE>viewDirection()</CODE></A> and to <A HREF="../../remixlab/proscene/Camera.html#rightVector()"><CODE>rightVector()</CODE></A>.
 <p>
 It corresponds to the Y axis of the associated <A HREF="../../remixlab/proscene/Camera.html#frame()"><CODE>frame()</CODE></A> (actually
 returns <code>frame().yAxis()</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUpVector(PVector)"><!-- --></A><H3>
setUpVector</H3>
<PRE>
public void <B>setUpVector</B>(PVector&nbsp;up)</PRE>
<DL>
<DD>Convenience function that simply calls <code>setUpVector(up, true)</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#setUpVector(PVector, boolean)"><CODE>setUpVector(PVector, boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setUpVector(PVector, boolean)"><!-- --></A><H3>
setUpVector</H3>
<PRE>
public void <B>setUpVector</B>(PVector&nbsp;up,
                        boolean&nbsp;noMove)</PRE>
<DL>
<DD>Rotates the Camera so that its <A HREF="../../remixlab/proscene/Camera.html#upVector()"><CODE>upVector()</CODE></A> becomes <code>up</code>
 (defined in the world coordinate system).
 <p>
 The Camera is rotated around an axis orthogonal to <code>up</code> and to the
 current <A HREF="../../remixlab/proscene/Camera.html#upVector()"><CODE>upVector()</CODE></A> direction.
 <p>
 Use this method in order to define the Camera horizontal plane.
 <p>
 When <code>noMove</code> is set to <code>false</code>, the orientation modification
 is compensated by a translation, so that the
 <A HREF="../../remixlab/proscene/Camera.html#arcballReferencePoint()"><CODE>arcballReferencePoint()</CODE></A> stays projected at the same position on
 screen. This is especially useful when the Camera is an observer of the
 scene (default mouse binding).
 <p>
 When <code>noMove</code> is true, the Camera <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A> is left
 unchanged, which is an intuitive behavior when the Camera is in a
 walkthrough fly mode.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#setViewDirection(PVector)"><CODE>setViewDirection(PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#lookAt(PVector)"><CODE>lookAt(PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#setOrientation(remixlab.proscene.Quaternion)"><CODE>setOrientation(Quaternion)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="viewDirection()"><!-- --></A><H3>
viewDirection</H3>
<PRE>
public PVector <B>viewDirection</B>()</PRE>
<DL>
<DD>Returns the normalized view direction of the Camera, defined in the world
 coordinate system.
 <p>
 Change this value using <A HREF="../../remixlab/proscene/Camera.html#setViewDirection(PVector)"><CODE>setViewDirection(PVector)</CODE></A>,
 <A HREF="../../remixlab/proscene/Camera.html#lookAt(PVector)"><CODE>lookAt(PVector)</CODE></A> or <A HREF="../../remixlab/proscene/Camera.html#setOrientation(remixlab.proscene.Quaternion)"><CODE>setOrientation(Quaternion)</CODE></A>. It is
 orthogonal to <A HREF="../../remixlab/proscene/Camera.html#upVector()"><CODE>upVector()</CODE></A> and to <A HREF="../../remixlab/proscene/Camera.html#rightVector()"><CODE>rightVector()</CODE></A>.
 <p>
 This corresponds to the negative Z axis of the <A HREF="../../remixlab/proscene/Camera.html#frame()"><CODE>frame()</CODE></A> ( <code>frame().inverseTransformOf(new PVector(0.0f, 0.0f, -1.0f))</code> ).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setViewDirection(PVector)"><!-- --></A><H3>
setViewDirection</H3>
<PRE>
public void <B>setViewDirection</B>(PVector&nbsp;direction)</PRE>
<DL>
<DD>Rotates the Camera so that its <A HREF="../../remixlab/proscene/Camera.html#viewDirection()"><CODE>viewDirection()</CODE></A> is <code>direction</code> (defined in the world coordinate system).
 <p>
 The Camera <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A> is not modified. The Camera is rotated so
 that the horizon (defined by its <A HREF="../../remixlab/proscene/Camera.html#upVector()"><CODE>upVector()</CODE></A>) is preserved.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#lookAt(PVector)"><CODE>lookAt(PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#setUpVector(PVector)"><CODE>setUpVector(PVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="rightVector()"><!-- --></A><H3>
rightVector</H3>
<PRE>
public PVector <B>rightVector</B>()</PRE>
<DL>
<DD>Returns the normalized right vector of the Camera, defined in the world
 coordinate system.
 <p>
 This vector lies in the Camera horizontal plane, directed along the X axis
 (orthogonal to <A HREF="../../remixlab/proscene/Camera.html#upVector()"><CODE>upVector()</CODE></A> and to <A HREF="../../remixlab/proscene/Camera.html#viewDirection()"><CODE>viewDirection()</CODE></A>. Set
 using <A HREF="../../remixlab/proscene/Camera.html#setUpVector(PVector)"><CODE>setUpVector(PVector)</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#lookAt(PVector)"><CODE>lookAt(PVector)</CODE></A> or
 <A HREF="../../remixlab/proscene/Camera.html#setOrientation(remixlab.proscene.Quaternion)"><CODE>setOrientation(Quaternion)</CODE></A>.
 <p>
 Simply returns <code>frame().xAxis()</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="orientation()"><!-- --></A><H3>
orientation</H3>
<PRE>
public <A HREF="../../remixlab/proscene/Quaternion.html" title="class in remixlab.proscene">Quaternion</A> <B>orientation</B>()</PRE>
<DL>
<DD>Returns the Camera orientation, defined in the world coordinate system.
 <p>
 Actually returns <code>frame().orientation()</code>. Use
 <A HREF="../../remixlab/proscene/Camera.html#setOrientation(remixlab.proscene.Quaternion)"><CODE>setOrientation(Quaternion)</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#setUpVector(PVector)"><CODE>setUpVector(PVector)</CODE></A> or
 <A HREF="../../remixlab/proscene/Camera.html#lookAt(PVector)"><CODE>lookAt(PVector)</CODE></A> to set the Camera orientation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOrientation(float, float)"><!-- --></A><H3>
setOrientation</H3>
<PRE>
public void <B>setOrientation</B>(float&nbsp;theta,
                           float&nbsp;phi)</PRE>
<DL>
<DD>Sets the <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A> of the Camera using polar coordinates.
 <p>
 <code>theta</code> rotates the Camera around its Y axis, and then <code>phi</code>
 rotates it around its X axis.
 <p>
 The polar coordinates are defined in the world coordinates system: <code>theta = phi = 0</code> means that the Camera is directed towards the world Z
 axis. Both angles are expressed in radians.
 <p>
 The <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A> of the Camera is unchanged, you may want to call
 <A HREF="../../remixlab/proscene/Camera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A> after this method to move the Camera.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#setUpVector(PVector)"><CODE>setUpVector(PVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setOrientation(remixlab.proscene.Quaternion)"><!-- --></A><H3>
setOrientation</H3>
<PRE>
public void <B>setOrientation</B>(<A HREF="../../remixlab/proscene/Quaternion.html" title="class in remixlab.proscene">Quaternion</A>&nbsp;q)</PRE>
<DL>
<DD>Sets the Camera <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A>, defined in the world coordinate
 system.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="type()"><!-- --></A><H3>
type</H3>
<PRE>
public final <A HREF="../../remixlab/proscene/Camera.Type.html" title="enum in remixlab.proscene">Camera.Type</A> <B>type</B>()</PRE>
<DL>
<DD>Returns the Camera.Type of the Camera.
 <p>
 Set by <A HREF="../../remixlab/proscene/Camera.html#setType(remixlab.proscene.Camera.Type)"><CODE>setType(Type)</CODE></A>.
 <p>
 A <A HREF="../../remixlab/proscene/Camera.Type.html#PERSPECTIVE"><CODE>Camera.Type.PERSPECTIVE</CODE></A> Camera uses a classical
 projection mainly defined by its <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A>.
 <p>
 With a <A HREF="../../remixlab/proscene/Camera.Type.html#ORTHOGRAPHIC"><CODE>Camera.Type.ORTHOGRAPHIC</CODE></A> <A HREF="../../remixlab/proscene/Camera.html#type()"><CODE>type()</CODE></A>,
 the <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> is meaningless and the width and height of the
 Camera frustum are inferred from the distance to the
 <A HREF="../../remixlab/proscene/Camera.html#arcballReferencePoint()"><CODE>arcballReferencePoint()</CODE></A> using <A HREF="../../remixlab/proscene/Camera.html#getOrthoWidthHeight()"><CODE>getOrthoWidthHeight()</CODE></A>.
 <p>
 Both types use <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A> (to define their
 clipping planes) and <A HREF="../../remixlab/proscene/Camera.html#aspectRatio()"><CODE>aspectRatio()</CODE></A> (for frustum shape).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="kind()"><!-- --></A><H3>
kind</H3>
<PRE>
public final <A HREF="../../remixlab/proscene/Camera.Kind.html" title="enum in remixlab.proscene">Camera.Kind</A> <B>kind</B>()</PRE>
<DL>
<DD>Returns the kind of the Camera: PROSCENE or STANDARD.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setKind(remixlab.proscene.Camera.Kind)"><!-- --></A><H3>
setKind</H3>
<PRE>
public void <B>setKind</B>(<A HREF="../../remixlab/proscene/Camera.Kind.html" title="enum in remixlab.proscene">Camera.Kind</A>&nbsp;k)</PRE>
<DL>
<DD>Sets the kind of the Camera: PROSCENE or STANDARD.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setStandardZNear(float)"><!-- --></A><H3>
setStandardZNear</H3>
<PRE>
public void <B>setStandardZNear</B>(float&nbsp;zN)</PRE>
<DL>
<DD>Sets the value of the <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A>. Meaningful only when the Camera
 <A HREF="../../remixlab/proscene/Camera.html#kind()"><CODE>kind()</CODE></A> is STANDARD. This value is set to 0.001 by default.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="standardZNear()"><!-- --></A><H3>
standardZNear</H3>
<PRE>
public float <B>standardZNear</B>()</PRE>
<DL>
<DD>Returns the value of the <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A>. Meaningful only when the Camera
 <A HREF="../../remixlab/proscene/Camera.html#kind()"><CODE>kind()</CODE></A> is STANDARD.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setStandardZFar(float)"><!-- --></A><H3>
setStandardZFar</H3>
<PRE>
public void <B>setStandardZFar</B>(float&nbsp;zF)</PRE>
<DL>
<DD>Sets the value of the <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A>. Meaningful only when the Camera
 <A HREF="../../remixlab/proscene/Camera.html#kind()"><CODE>kind()</CODE></A> is STANDARD. This value is set to 1000 by default.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="standardZFar()"><!-- --></A><H3>
standardZFar</H3>
<PRE>
public float <B>standardZFar</B>()</PRE>
<DL>
<DD>Returns the value of the <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A>. Meaningful only when the Camera
 <A HREF="../../remixlab/proscene/Camera.html#kind()"><CODE>kind()</CODE></A> is STANDARD.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="changeStandardOrthoFrustumSize(boolean)"><!-- --></A><H3>
changeStandardOrthoFrustumSize</H3>
<PRE>
public void <B>changeStandardOrthoFrustumSize</B>(boolean&nbsp;augment)</PRE>
<DL>
<DD>Changes the size of the frustum. If <code>augment</code> is true the frustum
 size is augmented, otherwise it is diminished. Meaningful only when the
 Camera <A HREF="../../remixlab/proscene/Camera.html#kind()"><CODE>kind()</CODE></A> is STANDARD and the Camera <A HREF="../../remixlab/proscene/Camera.html#type()"><CODE>type()</CODE></A> is
 ORTHOGRAPHIC.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#standardOrthoFrustumSize()"><CODE>standardOrthoFrustumSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="standardOrthoFrustumSize()"><!-- --></A><H3>
standardOrthoFrustumSize</H3>
<PRE>
public float <B>standardOrthoFrustumSize</B>()</PRE>
<DL>
<DD>Returns the frustum size. This value is used to set
 <A HREF="../../remixlab/proscene/Camera.html#getOrthoWidthHeight()"><CODE>getOrthoWidthHeight()</CODE></A>. Meaningful only when the Camera
 <A HREF="../../remixlab/proscene/Camera.html#kind()"><CODE>kind()</CODE></A> is STANDARD and the Camera <A HREF="../../remixlab/proscene/Camera.html#type()"><CODE>type()</CODE></A> is ORTHOGRAPHIC.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#getOrthoWidthHeight()"><CODE>getOrthoWidthHeight()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setType(remixlab.proscene.Camera.Type)"><!-- --></A><H3>
setType</H3>
<PRE>
public final void <B>setType</B>(<A HREF="../../remixlab/proscene/Camera.Type.html" title="enum in remixlab.proscene">Camera.Type</A>&nbsp;type)</PRE>
<DL>
<DD>Defines the Camera <A HREF="../../remixlab/proscene/Camera.html#type()"><CODE>type()</CODE></A>.
 <p>
 Changing the Camera Type alters the viewport and the objects' size can be
 changed. This method guarantees that the two frustum match in a plane
 normal to <A HREF="../../remixlab/proscene/Camera.html#viewDirection()"><CODE>viewDirection()</CODE></A>, passing through the arcball reference
 point.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="fieldOfView()"><!-- --></A><H3>
fieldOfView</H3>
<PRE>
public float <B>fieldOfView</B>()</PRE>
<DL>
<DD>Returns the vertical field of view of the Camera (in radians).
 <p>
 Value is set using <A HREF="../../remixlab/proscene/Camera.html#setFieldOfView(float)"><CODE>setFieldOfView(float)</CODE></A>. Default value is pi/4
 radians. This value is meaningless if the Camera <A HREF="../../remixlab/proscene/Camera.html#type()"><CODE>type()</CODE></A> is
 <A HREF="../../remixlab/proscene/Camera.Type.html#ORTHOGRAPHIC"><CODE>Camera.Type.ORTHOGRAPHIC</CODE></A>.
 <p>
 The field of view corresponds the one used in <code>gluPerspective</code> (see
 manual). It sets the Y (vertical) aperture of the Camera. The X
 (horizontal) angle is inferred from the window aspect ratio (see
 <A HREF="../../remixlab/proscene/Camera.html#aspectRatio()"><CODE>aspectRatio()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#horizontalFieldOfView()"><CODE>horizontalFieldOfView()</CODE></A>).
 <p>
 Use <A HREF="../../remixlab/proscene/Camera.html#setFOVToFitScene()"><CODE>setFOVToFitScene()</CODE></A> to adapt the <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> to a
 given scene.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFieldOfView(float)"><!-- --></A><H3>
setFieldOfView</H3>
<PRE>
public void <B>setFieldOfView</B>(float&nbsp;fov)</PRE>
<DL>
<DD>Sets the vertical <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> of the Camera (in radians).
 <p>
 Note that <A HREF="../../remixlab/proscene/Camera.html#focusDistance()"><CODE>focusDistance()</CODE></A> is set to <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> / tan(
 <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A>/2) by this method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFOVToFitScene()"><!-- --></A><H3>
setFOVToFitScene</H3>
<PRE>
public void <B>setFOVToFitScene</B>()</PRE>
<DL>
<DD>Changes the Camera <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> so that the entire scene (defined
 by <A HREF="../../remixlab/proscene/Scene.html#center()"><CODE>Scene.center()</CODE></A> and
 <A HREF="../../remixlab/proscene/Scene.html#radius()"><CODE>Scene.radius()</CODE></A> is visible from the Camera
 <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A>.
 <p>
 The <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A> of the Camera are not
 modified and you first have to orientate the Camera in order to actually
 see the scene (see <A HREF="../../remixlab/proscene/Camera.html#lookAt(PVector)"><CODE>lookAt(PVector)</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A> or
 <A HREF="../../remixlab/proscene/Camera.html#fitSphere(PVector, float)"><CODE>fitSphere(PVector, float)</CODE></A>).
 <p>
 This method is especially useful for <i>shadow maps</i> computation. Use
 the Camera positioning tools (<A HREF="../../remixlab/proscene/Camera.html#setPosition(PVector)"><CODE>setPosition(PVector)</CODE></A>,
 <A HREF="../../remixlab/proscene/Camera.html#lookAt(PVector)"><CODE>lookAt(PVector)</CODE></A>) to position a Camera at the light position. Then
 use this method to define the <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> so that the shadow map
 resolution is optimally used:
 <p>
 <code>// The light camera needs size hints in order to optimize its
 fieldOfView</code> <br>
 <code>lightCamera.setSceneRadius(sceneRadius());</code> <br>
 <code>lightCamera.setSceneCenter(sceneCenter());</code> <br>
 <code>// Place the light camera</code> <br>
 <code>lightCamera.setPosition(lightFrame.position());</code> <br>
 <code>lightCamera.lookAt(sceneCenter());</code> <br>
 <code>lightCamera.setFOVToFitScene();</code> <br>
 <p>
 <b>Attention:</b> The <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> is clamped to M_PI/2.0. This
 happens when the Camera is at a distance lower than sqrt(2.0) *
 sceneRadius() from the sceneCenter(). It optimizes the shadow map
 resolution, although it may miss some parts of the scene.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getOrthoWidthHeight()"><!-- --></A><H3>
getOrthoWidthHeight</H3>
<PRE>
public float[] <B>getOrthoWidthHeight</B>()</PRE>
<DL>
<DD>Convenience function that simply returns <code>getOrthoWidthHeight(new
 float[2])</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#getOrthoWidthHeight(float[])"><CODE>getOrthoWidthHeight(float[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getOrthoWidthHeight(float[])"><!-- --></A><H3>
getOrthoWidthHeight</H3>
<PRE>
public float[] <B>getOrthoWidthHeight</B>(float[]&nbsp;target)</PRE>
<DL>
<DD>Fills in <code>target</code> with the <code>halfWidth</code> and <code>halfHeight</code>
 of the Camera orthographic frustum and returns it.
 <p>
 While <code>target[0]</code> holds <code>halfWidth</code>, <code>target[1]</code> holds
 <code>halfHeight</code>.
 <p>
 These values are only valid and used when the Camera is of <A HREF="../../remixlab/proscene/Camera.html#type()"><CODE>type()</CODE></A>
 ORTHOGRAPHIC and they are expressed in processing scene units.
 <p>
 When the Camera <A HREF="../../remixlab/proscene/Camera.html#kind()"><CODE>kind()</CODE></A> is PROSCENE, these values are proportional
 to the Camera (z projected) distance to the
 <A HREF="../../remixlab/proscene/Camera.html#arcballReferencePoint()"><CODE>arcballReferencePoint()</CODE></A>. When zooming on the object, the Camera is
 translated forward \e and its frustum is narrowed, making the object appear
 bigger on screen, as intuitively expected.
 <p>
 When the Camera <A HREF="../../remixlab/proscene/Camera.html#kind()"><CODE>kind()</CODE></A> is STANDARD, these values are defined as
 <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> * <A HREF="../../remixlab/proscene/Camera.html#standardOrthoFrustumSize()"><CODE>standardOrthoFrustumSize()</CODE></A>.
 <p>
 Overload this method to change this behavior if desired.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="horizontalFieldOfView()"><!-- --></A><H3>
horizontalFieldOfView</H3>
<PRE>
public float <B>horizontalFieldOfView</B>()</PRE>
<DL>
<DD>Returns the horizontal field of view of the Camera (in radians).
 <p>
 Value is set using <A HREF="../../remixlab/proscene/Camera.html#setHorizontalFieldOfView(float)"><CODE>setHorizontalFieldOfView(float)</CODE></A> or
 <A HREF="../../remixlab/proscene/Camera.html#setFieldOfView(float)"><CODE>setFieldOfView(float)</CODE></A>. These values are always linked by: <code>horizontalFieldOfView() = 2.0 * atan ( tan(fieldOfView()/2.0) *
 aspectRatio() )</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setHorizontalFieldOfView(float)"><!-- --></A><H3>
setHorizontalFieldOfView</H3>
<PRE>
public void <B>setHorizontalFieldOfView</B>(float&nbsp;hfov)</PRE>
<DL>
<DD>Sets the <A HREF="../../remixlab/proscene/Camera.html#horizontalFieldOfView()"><CODE>horizontalFieldOfView()</CODE></A> of the Camera (in radians).
 <p>
 <A HREF="../../remixlab/proscene/Camera.html#horizontalFieldOfView()"><CODE>horizontalFieldOfView()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> are linked by
 the <A HREF="../../remixlab/proscene/Camera.html#aspectRatio()"><CODE>aspectRatio()</CODE></A>. This method actually calls <code>setFieldOfView(( 2.0 * atan (tan(hfov / 2.0) / aspectRatio()) ))</code> so that a
 call to <A HREF="../../remixlab/proscene/Camera.html#horizontalFieldOfView()"><CODE>horizontalFieldOfView()</CODE></A> returns the expected value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="aspectRatio()"><!-- --></A><H3>
aspectRatio</H3>
<PRE>
public float <B>aspectRatio</B>()</PRE>
<DL>
<DD>Returns the Camera aspect ratio defined by <A HREF="../../remixlab/proscene/Camera.html#screenWidth()"><CODE>screenWidth()</CODE></A> /
 <A HREF="../../remixlab/proscene/Camera.html#screenHeight()"><CODE>screenHeight()</CODE></A>.
 <p>
 When the Camera is attached to a Scene, these values and hence the
 aspectRatio() are automatically fitted to the viewer's window aspect ratio
 using setScreenWidthAndHeight().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAspectRatio(float)"><!-- --></A><H3>
setAspectRatio</H3>
<PRE>
public void <B>setAspectRatio</B>(float&nbsp;aspect)</PRE>
<DL>
<DD>Defines the Camera <A HREF="../../remixlab/proscene/Camera.html#aspectRatio()"><CODE>aspectRatio()</CODE></A>.
 <p>
 This value is actually inferred from the <A HREF="../../remixlab/proscene/Camera.html#screenWidth()"><CODE>screenWidth()</CODE></A> /
 <A HREF="../../remixlab/proscene/Camera.html#screenHeight()"><CODE>screenHeight()</CODE></A> ratio. You should use
 <A HREF="../../remixlab/proscene/Camera.html#setScreenWidthAndHeight(int, int)"><CODE>setScreenWidthAndHeight(int, int)</CODE></A> instead.
 <p>
 This method might however be convenient when the Camera is not associated
 with a Scene. It actually sets the <A HREF="../../remixlab/proscene/Camera.html#screenHeight()"><CODE>screenHeight()</CODE></A> to 100 and the
 <A HREF="../../remixlab/proscene/Camera.html#screenWidth()"><CODE>screenWidth()</CODE></A> accordingly. See also <A HREF="../../remixlab/proscene/Camera.html#setFOVToFitScene()"><CODE>setFOVToFitScene()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setScreenWidthAndHeight(int, int)"><!-- --></A><H3>
setScreenWidthAndHeight</H3>
<PRE>
public void <B>setScreenWidthAndHeight</B>(int&nbsp;width,
                                    int&nbsp;height)</PRE>
<DL>
<DD>Sets Camera <A HREF="../../remixlab/proscene/Camera.html#screenWidth()"><CODE>screenWidth()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#screenHeight()"><CODE>screenHeight()</CODE></A> (expressed
 in pixels).
 <p>
 You should not call this method when the Camera is associated with a Scene,
 since the latter automatically updates these values when it is resized
 (hence overwriting your values).
 <p>
 Non-positive dimension are silently replaced by a 1 pixel value to ensure
 frustum coherence.
 <p>
 If your Camera is used without a Scene (offscreen rendering, shadow maps),
 use <A HREF="../../remixlab/proscene/Camera.html#setAspectRatio(float)"><CODE>setAspectRatio(float)</CODE></A> instead to define the projection matrix.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="screenWidth()"><!-- --></A><H3>
screenWidth</H3>
<PRE>
public final int <B>screenWidth</B>()</PRE>
<DL>
<DD>Returns the width (in pixels) of the Camera screen.
 <p>
 Set using <A HREF="../../remixlab/proscene/Camera.html#setScreenWidthAndHeight(int, int)"><CODE>setScreenWidthAndHeight(int, int)</CODE></A>. This value is
 automatically fitted to the Scene's window dimensions when the Camera is
 attached to a Scene.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="screenHeight()"><!-- --></A><H3>
screenHeight</H3>
<PRE>
public final int <B>screenHeight</B>()</PRE>
<DL>
<DD>Returns the height (in pixels) of the Camera screen.
 <p>
 Set using <A HREF="../../remixlab/proscene/Camera.html#setScreenWidthAndHeight(int, int)"><CODE>setScreenWidthAndHeight(int, int)</CODE></A>. This value is
 automatically fitted to the Scene's window dimensions when the Camera is
 attached to a Scene.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getViewport()"><!-- --></A><H3>
getViewport</H3>
<PRE>
public int[] <B>getViewport</B>()</PRE>
<DL>
<DD>Convenience function that simply calls <code>return</code>
 <A HREF="../../remixlab/proscene/Camera.html#getViewport(int[])"><CODE>getViewport(int[])</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getViewport(int[])"><!-- --></A><H3>
getViewport</H3>
<PRE>
public int[] <B>getViewport</B>(int[]&nbsp;viewport)</PRE>
<DL>
<DD>Fills <code>viewport</code> with the Camera viewport and returns it. If viewport
 is null (or not the correct size), a new array will be created.
 <p>
 This method is mainly used in conjunction with
 <A HREF="../../remixlab/proscene/Camera.html#project(float, float, float, PMatrix3D, PMatrix3D, int[], float[])"><CODE>project(float, float, float, PMatrix3D, PMatrix3D, int[], float[])</CODE></A>
 , which requires such a viewport. Returned values are (0,
 <A HREF="../../remixlab/proscene/Camera.html#screenHeight()"><CODE>screenHeight()</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#screenWidth()"><CODE>screenWidth()</CODE></A>, -<A HREF="../../remixlab/proscene/Camera.html#screenHeight()"><CODE>screenHeight()</CODE></A>),
 so that the origin is located in the upper left corner of the window.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zNear()"><!-- --></A><H3>
zNear</H3>
<PRE>
public float <B>zNear</B>()</PRE>
<DL>
<DD>Returns the near clipping plane distance used by the Camera projection
 matrix. The returned value depends on the Camera <A HREF="../../remixlab/proscene/Camera.html#kind()"><CODE>kind()</CODE></A>:
 <p>
 <h3>1. If the camera kind is PROSCENE</h3>
 The clipping planes' positions depend on the <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> and
 <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> rather than being fixed small-enough and
 large-enough values. A good scene dimension approximation will hence result
 in an optimal precision of the z-buffer.
 <p>
 The near clipping plane is positioned at a distance equal to
 <A HREF="../../remixlab/proscene/Camera.html#zClippingCoefficient()"><CODE>zClippingCoefficient()</CODE></A> * <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> in front of the
 <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>: <code>distanceToSceneCenter() -
 zClippingCoefficient() * sceneRadius()</code>
 <p>
 In order to prevent negative or too small <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A> values (which
 would degrade the z precision), <A HREF="../../remixlab/proscene/Camera.html#zNearCoefficient()"><CODE>zNearCoefficient()</CODE></A> is used when
 the Camera is inside the <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> sphere:
 <p>
 <code>zMin = zNearCoefficient() * zClippingCoefficient() * sceneRadius();</code>
 <br>
 <code>zNear = zMin;</code><br>
 <code>// With an ORTHOGRAPHIC type, the value is simply clamped to 0.0</code>
 <br>
 <p>
 See also the <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#zClippingCoefficient()"><CODE>zClippingCoefficient()</CODE></A> and
 <A HREF="../../remixlab/proscene/Camera.html#zNearCoefficient()"><CODE>zNearCoefficient()</CODE></A> documentations.
 <p>
 <h3>2. If the camera kind is STANDARD</h3>
 Simply returns <A HREF="../../remixlab/proscene/Camera.html#standardZNear()"><CODE>standardZNear()</CODE></A>
 <P>
 If you need a completely different zNear computation, overload the
 <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A> methods in a new class that publicly
 inherits from Camera and use
 <A HREF="../../remixlab/proscene/Scene.html#setCamera(remixlab.proscene.Camera)"><CODE>Scene.setCamera(Camera)</CODE></A>.
 <p>
 <b>Attention:</b> The value is always positive although the clipping plane
 is positioned at a negative z value in the Camera coordinate system. This
 follows the <code>gluPerspective</code> standard.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="zFar()"><!-- --></A><H3>
zFar</H3>
<PRE>
public float <B>zFar</B>()</PRE>
<DL>
<DD>Returns the far clipping plane distance used by the Camera projection
 matrix. The returned value depends on the Camera <A HREF="../../remixlab/proscene/Camera.html#kind()"><CODE>kind()</CODE></A>:
 <p>
 <h3>1. If the camera kind is PROSCENE</h3>
 The far clipping plane is positioned at a distance equal to <code>zClippingCoefficient() * sceneRadius()</code> behind the <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>:
 <p>
 <code>zFar = distanceToSceneCenter() +
 zClippingCoefficient()*sceneRadius()</code><br>
 <h3>2. If the camera kind is STANDARD</h3>
 Simply returns <A HREF="../../remixlab/proscene/Camera.html#standardZFar()"><CODE>standardZFar()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="zNearCoefficient()"><!-- --></A><H3>
zNearCoefficient</H3>
<PRE>
public float <B>zNearCoefficient</B>()</PRE>
<DL>
<DD>Returns the coefficient which is used to set <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A> when the
 Camera is inside the sphere defined by <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> and
 <A HREF="../../remixlab/proscene/Camera.html#zClippingCoefficient()"><CODE>zClippingCoefficient()</CODE></A> * <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A>.
 <p>
 In that case, the <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A> value is set to <code>zNearCoefficient() * zClippingCoefficient() * sceneRadius()</code>. See the
 <code>zNear()</code> documentation for details.
 <p>
 Default value is 0.005, which is appropriate for most applications. In case
 you need a high dynamic ZBuffer precision, you can increase this value
 (~0.1). A lower value will prevent clipping of very close objects at the
 expense of a worst Z precision.
 <p>
 Only meaningful when Camera type is PERSPECTIVE.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setZNearCoefficient(float)"><!-- --></A><H3>
setZNearCoefficient</H3>
<PRE>
public void <B>setZNearCoefficient</B>(float&nbsp;coef)</PRE>
<DL>
<DD>Sets the <A HREF="../../remixlab/proscene/Camera.html#zNearCoefficient()"><CODE>zNearCoefficient()</CODE></A> value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zClippingCoefficient()"><!-- --></A><H3>
zClippingCoefficient</H3>
<PRE>
public float <B>zClippingCoefficient</B>()</PRE>
<DL>
<DD>Returns the coefficient used to position the near and far clipping planes.
 <p>
 The near (resp. far) clipping plane is positioned at a distance equal to
 <code>zClippingCoefficient() * sceneRadius()</code> in front of (resp. behind)
 the <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>. This guarantees an optimal use of the z-buffer
 range and minimizes aliasing. See the <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A>
 documentations.
 <p>
 Default value is square root of 3.0 (so that a cube of size
 <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> is not clipped).
 <p>
 However, since the <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> is used for other purposes (see
 showEntireScene(), flySpeed(), ...) and you may want to change this value
 to define more precisely the location of the clipping planes. See also
 <A HREF="../../remixlab/proscene/Camera.html#zNearCoefficient()"><CODE>zNearCoefficient()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setZClippingCoefficient(float)"><!-- --></A><H3>
setZClippingCoefficient</H3>
<PRE>
public void <B>setZClippingCoefficient</B>(float&nbsp;coef)</PRE>
<DL>
<DD>Sets the <A HREF="../../remixlab/proscene/Camera.html#zClippingCoefficient()"><CODE>zClippingCoefficient()</CODE></A> value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="pixelP5Ratio(PVector)"><!-- --></A><H3>
pixelP5Ratio</H3>
<PRE>
public float <B>pixelP5Ratio</B>(PVector&nbsp;position)</PRE>
<DL>
<DD>Returns the ratio between pixel and processing scene units at <code>position</code>.
 <p>
 A line of <code>n * pixelP5Ratio()</code> processing scene units, located at
 <code>position</code> in the world coordinates system, will be projected with a
 length of <code>n</code> pixels on screen.
 <p>
 Use this method to scale objects so that they have a constant pixel size on
 screen. The following code will draw a 20 pixel line, starting at
 <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> and always directed along the screen vertical
 direction:
 <p>
 <code>beginShape(LINES);</code><br>
 <code>vertex(sceneCenter().x, sceneCenter().y, sceneCenter().z);</code><br>
 <code>PVector v = PVector.add(sceneCenter(), PVector.mult(upVector(), 20 *
 pixelP5Ratio(sceneCenter())));</code><br>
 <code>vertex(v.x, v.y, v.z);</code><br>
 <code>endShape();</code><br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="distanceToFrustumPlane(int, PVector)"><!-- --></A><H3>
distanceToFrustumPlane</H3>
<PRE>
public float <B>distanceToFrustumPlane</B>(int&nbsp;index,
                                    PVector&nbsp;pos)</PRE>
<DL>
<DD>Returns the signed distance between point <code>pos</code> and plane <code>index</code>. The distance is negative if the point lies in the planes's frustum
 halfspace, and positive otherwise.
 <p>
 <code>index</code> is a value between <code>0</code> and <code>5</code> which respectively
 correspond to the left, right, near, far, top and bottom Camera frustum
 planes.
 <p>
 <b>Attention:</b> The camera frustum plane equations should be updated
 before calling this method. You may compute them explicitly (by calling
 <A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()"><CODE>computeFrustumEquations()</CODE></A> ) or enable them to be automatic updated
 in your Scene setup (with
 <A HREF="../../remixlab/proscene/Scene.html#enableFrustumEquationsUpdate()"><CODE>Scene.enableFrustumEquationsUpdate()</CODE></A>).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#pointIsVisible(PVector)"><CODE>pointIsVisible(PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#sphereIsVisible(PVector, float)"><CODE>sphereIsVisible(PVector, float)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#aaBoxIsVisible(PVector, PVector)"><CODE>aaBoxIsVisible(PVector, PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()"><CODE>computeFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#updateFrustumEquations()"><CODE>updateFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#getFrustumEquations()"><CODE>getFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Scene.html#enableFrustumEquationsUpdate()"><CODE>Scene.enableFrustumEquationsUpdate()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="pointIsVisible(PVector)"><!-- --></A><H3>
pointIsVisible</H3>
<PRE>
public boolean <B>pointIsVisible</B>(PVector&nbsp;point)</PRE>
<DL>
<DD>Returns <code>true</code> if <code>point</code> is visible (i.e, lies within the
 frustum) and <code>false</code> otherwise.
 <p>
 <b>Attention:</b> The camera frustum plane equations should be updated
 before calling this method. You may compute them explicitly (by calling
 <A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()"><CODE>computeFrustumEquations()</CODE></A> ) or enable them to be automatic updated
 in your Scene setup (with
 <A HREF="../../remixlab/proscene/Scene.html#enableFrustumEquationsUpdate()"><CODE>Scene.enableFrustumEquationsUpdate()</CODE></A>).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#distanceToFrustumPlane(int, PVector)"><CODE>distanceToFrustumPlane(int, PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#sphereIsVisible(PVector, float)"><CODE>sphereIsVisible(PVector, float)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#aaBoxIsVisible(PVector, PVector)"><CODE>aaBoxIsVisible(PVector, PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()"><CODE>computeFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#updateFrustumEquations()"><CODE>updateFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#getFrustumEquations()"><CODE>getFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Scene.html#enableFrustumEquationsUpdate()"><CODE>Scene.enableFrustumEquationsUpdate()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="sphereIsVisible(PVector, float)"><!-- --></A><H3>
sphereIsVisible</H3>
<PRE>
public <A HREF="../../remixlab/proscene/Camera.Visibility.html" title="enum in remixlab.proscene">Camera.Visibility</A> <B>sphereIsVisible</B>(PVector&nbsp;center,
                                         float&nbsp;radius)</PRE>
<DL>
<DD>Returns <A HREF="../../remixlab/proscene/Camera.Visibility.html#VISIBLE"><CODE>Camera.Visibility.VISIBLE</CODE></A>,
 <A HREF="../../remixlab/proscene/Camera.Visibility.html#INVISIBLE"><CODE>Camera.Visibility.INVISIBLE</CODE></A>, or
 <A HREF="../../remixlab/proscene/Camera.Visibility.html#SEMIVISIBLE"><CODE>Camera.Visibility.SEMIVISIBLE</CODE></A>, depending whether
 the sphere (of radius <code>radius</code> and center <code>center</code>) is visible,
 invisible, or semi-visible, respectively.
 <p>
 <b>Attention:</b> The camera frustum plane equations should be updated
 before calling this method. You may compute them explicitly (by calling
 <A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()"><CODE>computeFrustumEquations()</CODE></A> ) or enable them to be automatic updated
 in your Scene setup (with
 <A HREF="../../remixlab/proscene/Scene.html#enableFrustumEquationsUpdate()"><CODE>Scene.enableFrustumEquationsUpdate()</CODE></A>).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#distanceToFrustumPlane(int, PVector)"><CODE>distanceToFrustumPlane(int, PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#pointIsVisible(PVector)"><CODE>pointIsVisible(PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#aaBoxIsVisible(PVector, PVector)"><CODE>aaBoxIsVisible(PVector, PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()"><CODE>computeFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#updateFrustumEquations()"><CODE>updateFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#getFrustumEquations()"><CODE>getFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Scene.html#enableFrustumEquationsUpdate()"><CODE>Scene.enableFrustumEquationsUpdate()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="aaBoxIsVisible(PVector, PVector)"><!-- --></A><H3>
aaBoxIsVisible</H3>
<PRE>
public <A HREF="../../remixlab/proscene/Camera.Visibility.html" title="enum in remixlab.proscene">Camera.Visibility</A> <B>aaBoxIsVisible</B>(PVector&nbsp;p1,
                                        PVector&nbsp;p2)</PRE>
<DL>
<DD>Returns <A HREF="../../remixlab/proscene/Camera.Visibility.html#VISIBLE"><CODE>Camera.Visibility.VISIBLE</CODE></A>,
 <A HREF="../../remixlab/proscene/Camera.Visibility.html#INVISIBLE"><CODE>Camera.Visibility.INVISIBLE</CODE></A>, or
 <A HREF="../../remixlab/proscene/Camera.Visibility.html#SEMIVISIBLE"><CODE>Camera.Visibility.SEMIVISIBLE</CODE></A>, depending whether
 the axis aligned box (defined by corners <code>p1</code> and <code>p2</code>) is
 visible, invisible, or semi-visible, respectively.
 <p>
 <b>Attention:</b> The camera frustum plane equations should be updated
 before calling this method. You may compute them explicitly (by calling
 <A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()"><CODE>computeFrustumEquations()</CODE></A> ) or enable them to be automatic updated
 in your Scene setup (with
 <A HREF="../../remixlab/proscene/Scene.html#enableFrustumEquationsUpdate()"><CODE>Scene.enableFrustumEquationsUpdate()</CODE></A>).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#distanceToFrustumPlane(int, PVector)"><CODE>distanceToFrustumPlane(int, PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#pointIsVisible(PVector)"><CODE>pointIsVisible(PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#sphereIsVisible(PVector, float)"><CODE>sphereIsVisible(PVector, float)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()"><CODE>computeFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#updateFrustumEquations()"><CODE>updateFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#getFrustumEquations()"><CODE>getFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Scene.html#enableFrustumEquationsUpdate()"><CODE>Scene.enableFrustumEquationsUpdate()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="updateFrustumEquations()"><!-- --></A><H3>
updateFrustumEquations</H3>
<PRE>
public void <B>updateFrustumEquations</B>()</PRE>
<DL>
<DD>Updates the frustum plane equations according to the current camera setup /
 <A HREF="../../remixlab/proscene/Camera.html#type()"><CODE>type()</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A>,
 <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A>, and <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A> values), by simply calling
 <A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()"><CODE>computeFrustumEquations()</CODE></A>.
 <p>
 <b>Attention:</b> You should not call this method explicitly, unless you
 need the frustum equations to be updated only occasionally (rare). Use
 <A HREF="../../remixlab/proscene/Scene.html#enableFrustumEquationsUpdate()"><CODE>Scene.enableFrustumEquationsUpdate()</CODE></A> which
 automatically update the frustum equations every frame instead.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#distanceToFrustumPlane(int, PVector)"><CODE>distanceToFrustumPlane(int, PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#pointIsVisible(PVector)"><CODE>pointIsVisible(PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#sphereIsVisible(PVector, float)"><CODE>sphereIsVisible(PVector, float)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#aaBoxIsVisible(PVector, PVector)"><CODE>aaBoxIsVisible(PVector, PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()"><CODE>computeFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#getFrustumEquations()"><CODE>getFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Scene.html#enableFrustumEquationsUpdate()"><CODE>Scene.enableFrustumEquationsUpdate()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFrustumEquations()"><!-- --></A><H3>
getFrustumEquations</H3>
<PRE>
public float[][] <B>getFrustumEquations</B>()</PRE>
<DL>
<DD>Returns the frustum plane equations.
 <p>
 The six 4-component vectors returned by this method, respectively
 correspond to the left, right, near, far, top and bottom Camera frustum
 planes. Each vector holds a plane equation of the form:
 <p>
 <code>a*x + b*y + c*z + d = 0</code>
 <p>
 where <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> are the 4 components of
 each vector, in that order.
 <p>
 <b>Attention:</b> The camera frustum plane equations should be updated
 before calling this method. You may compute them explicitly (by calling
 <A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()"><CODE>computeFrustumEquations()</CODE></A> ) or enable them to be automatic updated
 in your Scene setup (with
 <A HREF="../../remixlab/proscene/Scene.html#enableFrustumEquationsUpdate()"><CODE>Scene.enableFrustumEquationsUpdate()</CODE></A>).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#distanceToFrustumPlane(int, PVector)"><CODE>distanceToFrustumPlane(int, PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#pointIsVisible(PVector)"><CODE>pointIsVisible(PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#sphereIsVisible(PVector, float)"><CODE>sphereIsVisible(PVector, float)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#aaBoxIsVisible(PVector, PVector)"><CODE>aaBoxIsVisible(PVector, PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()"><CODE>computeFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#updateFrustumEquations()"><CODE>updateFrustumEquations()</CODE></A>, 
<A HREF="../../remixlab/proscene/Scene.html#enableFrustumEquationsUpdate()"><CODE>Scene.enableFrustumEquationsUpdate()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="computeFrustumEquations()"><!-- --></A><H3>
computeFrustumEquations</H3>
<PRE>
public float[][] <B>computeFrustumEquations</B>()</PRE>
<DL>
<DD>Convenience function that simply returns <code>computeFrustumPlanesCoefficients(new float [6][4])</code>
 <p>
 <b>Attention:</b> You should not call this method explicitly, unless you
 need the frustum equations to be updated only occasionally (rare). Use
 <A HREF="../../remixlab/proscene/Scene.html#enableFrustumEquationsUpdate()"><CODE>Scene.enableFrustumEquationsUpdate()</CODE></A> which
 automatically update the frustum equations every frame instead.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations(float[][])"><CODE>computeFrustumEquations(float[][])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="computeFrustumEquations(float[][])"><!-- --></A><H3>
computeFrustumEquations</H3>
<PRE>
public float[][] <B>computeFrustumEquations</B>(float[][]&nbsp;coef)</PRE>
<DL>
<DD>Fills <code>coef</code> with the 6 plane equations of the camera frustum and
 returns it.
 <p>
 The six 4-component vectors of <code>coef</code> respectively correspond to the
 left, right, near, far, top and bottom Camera frustum planes. Each vector
 holds a plane equation of the form:
 <p>
 <code>a*x + b*y + c*z + d = 0</code>
 <p>
 where <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> are the 4 components of
 each vector, in that order.
 <p>
 This format is compatible with the <code>gl.glClipPlane()</code> function. One
 camera frustum plane can hence be applied in an other viewer to visualize
 the culling results:
 <p>
 <code>// Retrieve place equations</code><br>
 <code>float [][] coef =
 mainViewer.camera().getFrustumPlanesCoefficients();</code><br>
 <code>// These two additional clipping planes (which must have been enabled)</code><br>
 <code>// will reproduce the mainViewer's near and far clipping.</code><br>
 <code>gl.glClipPlane(GL.GL_CLIP_PLANE0, coef[2]);</code><br>
 <code>gl.glClipPlane(GL.GL_CLIP_PLANE1, coef[3]);</code><br>
 <p>
 <b>Attention:</b> You should not call this method explicitly, unless you
 need the frustum equations to be updated only occasionally (rare). Use
 <A HREF="../../remixlab/proscene/Scene.html#enableFrustumEquationsUpdate()"><CODE>Scene.enableFrustumEquationsUpdate()</CODE></A> which
 automatically update the frustum equations every frame instead.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#computeFrustumEquations()"><CODE>computeFrustumEquations()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="enableFrustumEquationsUpdate(boolean)"><!-- --></A><H3>
enableFrustumEquationsUpdate</H3>
<PRE>
protected void <B>enableFrustumEquationsUpdate</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>Enables or disables automatic update of the camera frustum plane equations
 every frame according to <code>flag</code>. Computation of the equations is
 expensive and hence is disabled by default.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#updateFrustumEquations()"><CODE>updateFrustumEquations()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="frustumEquationsUpdateIsEnable()"><!-- --></A><H3>
frustumEquationsUpdateIsEnable</H3>
<PRE>
protected boolean <B>frustumEquationsUpdateIsEnable</B>()</PRE>
<DL>
<DD>Returns <code>true</code> if automatic update of the camera frustum plane
 equations is enabled and <code>false</code> otherwise. Computation of the
 equations is expensive and hence is disabled by default.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#updateFrustumEquations()"><CODE>updateFrustumEquations()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="coneIsBackFacing(java.util.ArrayList)"><!-- --></A><H3>
coneIsBackFacing</H3>
<PRE>
public boolean <B>coneIsBackFacing</B>(java.util.ArrayList&lt;PVector&gt;&nbsp;normals)</PRE>
<DL>
<DD>Convenience function that simply calls <code>coneIsBackFacing(new Cone(normals))</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(remixlab.proscene.Camera.Cone)"><CODE>coneIsBackFacing(Cone)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(PVector[])"><CODE>coneIsBackFacing(PVector[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="coneIsBackFacing(PVector, java.util.ArrayList)"><!-- --></A><H3>
coneIsBackFacing</H3>
<PRE>
public boolean <B>coneIsBackFacing</B>(PVector&nbsp;viewDirection,
                                java.util.ArrayList&lt;PVector&gt;&nbsp;normals)</PRE>
<DL>
<DD>Convenience function that simply calls
 {coneIsBackFacing(viewDirection, new Cone(normals))}.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>viewDirection</CODE> - Cached camera view direction.<DD><CODE>normals</CODE> - cone of normals.</DL>
</DD>
</DL>
<HR>

<A NAME="coneIsBackFacing(PVector[])"><!-- --></A><H3>
coneIsBackFacing</H3>
<PRE>
public boolean <B>coneIsBackFacing</B>(PVector[]&nbsp;normals)</PRE>
<DL>
<DD>Convenience function that simply calls <code>coneIsBackFacing(new Cone(normals))</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(remixlab.proscene.Camera.Cone)"><CODE>coneIsBackFacing(Cone)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(java.util.ArrayList)"><CODE>coneIsBackFacing(ArrayList)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="coneIsBackFacing(PVector, PVector[])"><!-- --></A><H3>
coneIsBackFacing</H3>
<PRE>
public boolean <B>coneIsBackFacing</B>(PVector&nbsp;viewDirection,
                                PVector[]&nbsp;normals)</PRE>
<DL>
<DD>Convenience function that simply returns
 <code>coneIsBackFacing(viewDirection, new Cone(normals))</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>viewDirection</CODE> - Cached camera view direction.<DD><CODE>normals</CODE> - cone of normals.</DL>
</DD>
</DL>
<HR>

<A NAME="coneIsBackFacing(remixlab.proscene.Camera.Cone)"><!-- --></A><H3>
coneIsBackFacing</H3>
<PRE>
public boolean <B>coneIsBackFacing</B>(<A HREF="../../remixlab/proscene/Camera.Cone.html" title="class in remixlab.proscene">Camera.Cone</A>&nbsp;cone)</PRE>
<DL>
<DD>Convenience function that simply returns <code>coneIsBackFacing(cone.axis(), cone.angle())</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(PVector, float)"><CODE>coneIsBackFacing(PVector, float)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#faceIsBackFacing(PVector, PVector, PVector)"><CODE>faceIsBackFacing(PVector, PVector, PVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="coneIsBackFacing(PVector, remixlab.proscene.Camera.Cone)"><!-- --></A><H3>
coneIsBackFacing</H3>
<PRE>
public boolean <B>coneIsBackFacing</B>(PVector&nbsp;viewDirection,
                                <A HREF="../../remixlab/proscene/Camera.Cone.html" title="class in remixlab.proscene">Camera.Cone</A>&nbsp;cone)</PRE>
<DL>
<DD>Convenience function that simply returns 
 <code>coneIsBackFacing(viewDirection, cone.axis(), cone.angle())</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>viewDirection</CODE> - cached camera view direction.<DD><CODE>cone</CODE> - cone of normals</DL>
</DD>
</DL>
<HR>

<A NAME="coneIsBackFacing(PVector, float)"><!-- --></A><H3>
coneIsBackFacing</H3>
<PRE>
public boolean <B>coneIsBackFacing</B>(PVector&nbsp;axis,
                                float&nbsp;angle)</PRE>
<DL>
<DD>Convinience funtion that simply returns
 <code>coneIsBackFacing(viewDirection(), axis, angle)</code>.
 <p>
 Non-cached version of <A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(PVector, PVector, float)"><CODE>coneIsBackFacing(PVector, PVector, float)</CODE></A>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="coneIsBackFacing(PVector, PVector, float)"><!-- --></A><H3>
coneIsBackFacing</H3>
<PRE>
public boolean <B>coneIsBackFacing</B>(PVector&nbsp;viewDirection,
                                PVector&nbsp;axis,
                                float&nbsp;angle)</PRE>
<DL>
<DD>Returns <code>true</code> if the given cone is back facing the camera.
 Otherwise returns <code>false</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>viewDirection</CODE> - cached view direction<DD><CODE>axis</CODE> - normalized cone axis<DD><CODE>angle</CODE> - cone angle<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#coneIsBackFacing(remixlab.proscene.Camera.Cone)"><CODE>coneIsBackFacing(Cone)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#faceIsBackFacing(PVector, PVector, PVector)"><CODE>faceIsBackFacing(PVector, PVector, PVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="faceIsBackFacing(PVector, PVector, PVector)"><!-- --></A><H3>
faceIsBackFacing</H3>
<PRE>
public boolean <B>faceIsBackFacing</B>(PVector&nbsp;a,
                                PVector&nbsp;b,
                                PVector&nbsp;c)</PRE>
<DL>
<DD>Returns <code>true</code> if the given face is back facing the camera.
 Otherwise returns <code>false</code>.
 <p>
 <b>Attention:</b> This method is not computationally optimized.
 If you call it several times with no change in the matrices, you should
 buffer the matrices (modelview, projection and then viewport) to speed-up the
 queries.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - first face vertex<DD><CODE>b</CODE> - second face vertex<DD><CODE>c</CODE> - third face vertex</DL>
</DD>
</DL>
<HR>

<A NAME="sceneRadius()"><!-- --></A><H3>
sceneRadius</H3>
<PRE>
public float <B>sceneRadius</B>()</PRE>
<DL>
<DD>Returns the radius of the scene observed by the Camera.
 <p>
 You need to provide such an approximation of the scene dimensions so that
 the Camera can adapt its <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A> values. See
 the <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> documentation.
 <p>
 Note that Scene.sceneRadius() (resp. Scene.setSceneRadius()) simply call
 this method on its associated Camera.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#setSceneBoundingBox(PVector, PVector)"><CODE>setSceneBoundingBox(PVector, PVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setSceneRadius(float)"><!-- --></A><H3>
setSceneRadius</H3>
<PRE>
public void <B>setSceneRadius</B>(float&nbsp;radius)</PRE>
<DL>
<DD>Sets the <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> value. Negative values are ignored.
 <p>
 <b>Attention:</b> This methods also sets <A HREF="../../remixlab/proscene/Camera.html#focusDistance()"><CODE>focusDistance()</CODE></A> to
 <code>sceneRadius() / tan(fieldOfView()/2)</code> and <A HREF="../../remixlab/proscene/Camera.html#flySpeed()"><CODE>flySpeed()</CODE></A> to 1%
 of <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> (if there's an Scene
 <A HREF="../../remixlab/proscene/Scene.html#avatar()"><CODE>Scene.avatar()</CODE></A> and it is an instance of
 InteractiveDrivableFrame it also sets <code>flySpeed</code> to the same value).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sceneCenter()"><!-- --></A><H3>
sceneCenter</H3>
<PRE>
public PVector <B>sceneCenter</B>()</PRE>
<DL>
<DD>Returns the position of the scene center, defined in the world coordinate
 system.
 <p>
 The scene observed by the Camera should be roughly centered on this
 position, and included in a <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> sphere. This approximate
 description of the scene permits a <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A>
 clipping planes definition, and allows convenient positioning methods such
 as <A HREF="../../remixlab/proscene/Camera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A>.
 <p>
 Note that <A HREF="../../remixlab/proscene/Scene.html#center()"><CODE>Scene.center()</CODE></A> (resp.
 remixlab.proscene.Scene<A HREF="../../remixlab/proscene/Camera.html#setSceneCenter(PVector)"><CODE>setSceneCenter(PVector)</CODE></A>) simply call this
 method (resp. <A HREF="../../remixlab/proscene/Camera.html#setSceneCenter(PVector)"><CODE>setSceneCenter(PVector)</CODE></A>) on its associated
 <A HREF="../../remixlab/proscene/Scene.html#camera()"><CODE>Scene.camera()</CODE></A>. Default value is (0,0,0) (world
 origin). Use <A HREF="../../remixlab/proscene/Camera.html#setSceneCenter(PVector)"><CODE>setSceneCenter(PVector)</CODE></A> to change it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#setSceneBoundingBox(PVector, PVector)"><CODE>setSceneBoundingBox(PVector, PVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setSceneCenter(PVector)"><!-- --></A><H3>
setSceneCenter</H3>
<PRE>
public void <B>setSceneCenter</B>(PVector&nbsp;center)</PRE>
<DL>
<DD>Sets the <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>.
 <p>
 <b>Attention:</b> This method also sets the
 <A HREF="../../remixlab/proscene/Camera.html#arcballReferencePoint()"><CODE>arcballReferencePoint()</CODE></A> to <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="distanceToSceneCenter()"><!-- --></A><H3>
distanceToSceneCenter</H3>
<PRE>
public float <B>distanceToSceneCenter</B>()</PRE>
<DL>
<DD>Returns the distance from the Camera center to <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>,
 projected along the Camera Z axis.
 <p>
 Used by <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A> to optimize the Z range.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setSceneBoundingBox(PVector, PVector)"><!-- --></A><H3>
setSceneBoundingBox</H3>
<PRE>
public void <B>setSceneBoundingBox</B>(PVector&nbsp;min,
                                PVector&nbsp;max)</PRE>
<DL>
<DD>Similar to <A HREF="../../remixlab/proscene/Camera.html#setSceneRadius(float)"><CODE>setSceneRadius(float)</CODE></A> and
 <A HREF="../../remixlab/proscene/Camera.html#setSceneCenter(PVector)"><CODE>setSceneCenter(PVector)</CODE></A>, but the scene limits are defined by a
 (world axis aligned) bounding box.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="arcballReferencePoint()"><!-- --></A><H3>
arcballReferencePoint</H3>
<PRE>
public final PVector <B>arcballReferencePoint</B>()</PRE>
<DL>
<DD>The point the Camera revolves around with the
 <A HREF="../../remixlab/proscene/Scene.MouseAction.html#ROTATE"><CODE>Scene.MouseAction.ROTATE</CODE></A> mouse binding. Defined
 in world coordinate system.
 <p>
 Default value is the <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>.
 <p>
 <b>Attention:</b> <A HREF="../../remixlab/proscene/Camera.html#setSceneCenter(PVector)"><CODE>setSceneCenter(PVector)</CODE></A> changes this value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setArcballReferencePoint(PVector)"><!-- --></A><H3>
setArcballReferencePoint</H3>
<PRE>
public void <B>setArcballReferencePoint</B>(PVector&nbsp;rap)</PRE>
<DL>
<DD>Changes the <A HREF="../../remixlab/proscene/Camera.html#arcballReferencePoint()"><CODE>arcballReferencePoint()</CODE></A> to <code>rap</code> (defined in the
 world coordinate system).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setArcballReferencePointFromPixel(remixlab.proscene.Point)"><!-- --></A><H3>
setArcballReferencePointFromPixel</H3>
<PRE>
public boolean <B>setArcballReferencePointFromPixel</B>(<A HREF="../../remixlab/proscene/Point.html" title="class in remixlab.proscene">Point</A>&nbsp;pixel)</PRE>
<DL>
<DD>The <A HREF="../../remixlab/proscene/Camera.html#arcballReferencePoint()"><CODE>arcballReferencePoint()</CODE></A> is set to the point located under
 <code>pixel</code> on screen. Returns <code>true</code> if a point was found under
 <code>pixel</code> and <code>false</code> if none was found (in this case no
 <A HREF="../../remixlab/proscene/Camera.html#arcballReferencePoint()"><CODE>arcballReferencePoint()</CODE></A> is set).
 <p>
 Override <A HREF="../../remixlab/proscene/Camera.html#pointUnderPixel(remixlab.proscene.Point)"><CODE>pointUnderPixel(Point)</CODE></A> in your jogl-based camera class.
 <p>
 Current implementation always returns <code>false</code>, meaning that no point
 was set.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setSceneCenterFromPixel(remixlab.proscene.Point)"><!-- --></A><H3>
setSceneCenterFromPixel</H3>
<PRE>
public boolean <B>setSceneCenterFromPixel</B>(<A HREF="../../remixlab/proscene/Point.html" title="class in remixlab.proscene">Point</A>&nbsp;pixel)</PRE>
<DL>
<DD>The <A HREF="../../remixlab/proscene/Camera.html#setSceneCenter(PVector)"><CODE>setSceneCenter(PVector)</CODE></A> is set to the point located under
 <code>pixel</code> on screen. Returns <code>true</code> if a point was found under
 <code>pixel</code> and <code>false</code> if none was found (in this case no
 <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> is set).
 <p>
 Override <A HREF="../../remixlab/proscene/Camera.html#pointUnderPixel(remixlab.proscene.Point)"><CODE>pointUnderPixel(Point)</CODE></A> in your jogl-based camera class.
 <p>
 Current implementation always returns <code>false</code>, meaning that no point
 was set.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="pointUnderPixel(remixlab.proscene.Point)"><!-- --></A><H3>
pointUnderPixel</H3>
<PRE>
public <A HREF="../../remixlab/proscene/Camera.WorldPoint.html" title="class in remixlab.proscene">Camera.WorldPoint</A> <B>pointUnderPixel</B>(<A HREF="../../remixlab/proscene/Point.html" title="class in remixlab.proscene">Point</A>&nbsp;pixel)</PRE>
<DL>
<DD>Returns the coordinates of the 3D point located at <code>pixel</code> (x,y) on
 screen.
 <p>
 Override this method in your jogl-based camera class.
 <p>
 Current implementation always returns <code>WorlPoint.found = false</code>
 (dummy value), meaning that no point was found under pixel.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="frame()"><!-- --></A><H3>
frame</H3>
<PRE>
public <A HREF="../../remixlab/proscene/InteractiveCameraFrame.html" title="class in remixlab.proscene">InteractiveCameraFrame</A> <B>frame</B>()</PRE>
<DL>
<DD>Returns the InteractiveCameraFrame attached to the Camera.
 <p>
 This InteractiveCameraFrame defines its <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A> and
 <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A> and can translate mouse events into Camera
 displacement. Set using <A HREF="../../remixlab/proscene/Camera.html#setFrame(remixlab.proscene.InteractiveCameraFrame)"><CODE>setFrame(InteractiveCameraFrame)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFrame(remixlab.proscene.InteractiveCameraFrame)"><!-- --></A><H3>
setFrame</H3>
<PRE>
public final void <B>setFrame</B>(<A HREF="../../remixlab/proscene/InteractiveCameraFrame.html" title="class in remixlab.proscene">InteractiveCameraFrame</A>&nbsp;icf)</PRE>
<DL>
<DD>Sets the Camera <A HREF="../../remixlab/proscene/Camera.html#frame()"><CODE>frame()</CODE></A>.
 <p>
 If you want to move the Camera, use <A HREF="../../remixlab/proscene/Camera.html#setPosition(PVector)"><CODE>setPosition(PVector)</CODE></A> and
 <A HREF="../../remixlab/proscene/Camera.html#setOrientation(remixlab.proscene.Quaternion)"><CODE>setOrientation(Quaternion)</CODE></A> or one of the Camera positioning
 methods (<A HREF="../../remixlab/proscene/Camera.html#lookAt(PVector)"><CODE>lookAt(PVector)</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#fitSphere(PVector, float)"><CODE>fitSphere(PVector, float)</CODE></A>,
 <A HREF="../../remixlab/proscene/Camera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A>...) instead.
 <p>
 This method is actually mainly useful if you derive the
 InteractiveCameraFrame class and want to use an instance of your new class
 to move the Camera.
 <p>
 A <code>null</code> <code>icf</code> reference will silently be ignored.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="spinningSensitivity()"><!-- --></A><H3>
spinningSensitivity</H3>
<PRE>
public final float <B>spinningSensitivity</B>()</PRE>
<DL>
<DD>Convenience wrapper function that simply returns <code>frame().spinningSensitivity()</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/InteractiveFrame.html#spinningSensitivity()"><CODE>InteractiveFrame.spinningSensitivity()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setSpinningSensitivity(float)"><!-- --></A><H3>
setSpinningSensitivity</H3>
<PRE>
public final void <B>setSpinningSensitivity</B>(float&nbsp;sensitivity)</PRE>
<DL>
<DD>Convenience wrapper function that simply calls <code>frame().setSpinningSensitivity(sensitivity)</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/InteractiveFrame.html#setSpinningSensitivity(float)"><CODE>InteractiveFrame.setSpinningSensitivity(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="rotationSensitivity()"><!-- --></A><H3>
rotationSensitivity</H3>
<PRE>
public final float <B>rotationSensitivity</B>()</PRE>
<DL>
<DD>Convenience wrapper function that simply returns <code>frame().rotationSensitivity()</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/InteractiveFrame.html#rotationSensitivity()"><CODE>InteractiveFrame.rotationSensitivity()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setRotationSensitivity(float)"><!-- --></A><H3>
setRotationSensitivity</H3>
<PRE>
public final void <B>setRotationSensitivity</B>(float&nbsp;sensitivity)</PRE>
<DL>
<DD>Convenience wrapper function that simply calls <code>frame().setRotationSensitivity(sensitivity)</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/InteractiveFrame.html#setRotationSensitivity(float)"><CODE>InteractiveFrame.setRotationSensitivity(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="translationSensitivity()"><!-- --></A><H3>
translationSensitivity</H3>
<PRE>
public final float <B>translationSensitivity</B>()</PRE>
<DL>
<DD>Convenience wrapper function that simply returns <code>frame().translationSensitivity()</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/InteractiveFrame.html#translationSensitivity()"><CODE>InteractiveFrame.translationSensitivity()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setTranslationSensitivity(float)"><!-- --></A><H3>
setTranslationSensitivity</H3>
<PRE>
public final void <B>setTranslationSensitivity</B>(float&nbsp;sensitivity)</PRE>
<DL>
<DD>Convenience wrapper function that simply calls <code>frame().setTranslationSensitivity(sensitivity)</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/InteractiveFrame.html#setTranslationSensitivity(float)"><CODE>InteractiveFrame.setTranslationSensitivity(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="keyFrameInterpolator(int)"><!-- --></A><H3>
keyFrameInterpolator</H3>
<PRE>
public <A HREF="../../remixlab/proscene/KeyFrameInterpolator.html" title="class in remixlab.proscene">KeyFrameInterpolator</A> <B>keyFrameInterpolator</B>(int&nbsp;key)</PRE>
<DL>
<DD>Returns the KeyFrameInterpolator that defines the Camera path number
 <code>key</code>.
 <p>
 The returned KeyFrameInterpolator may be null (if no path is defined for
 key <code>key</code>).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setKeyFrameInterpolator(int, remixlab.proscene.KeyFrameInterpolator)"><!-- --></A><H3>
setKeyFrameInterpolator</H3>
<PRE>
public void <B>setKeyFrameInterpolator</B>(int&nbsp;key,
                                    <A HREF="../../remixlab/proscene/KeyFrameInterpolator.html" title="class in remixlab.proscene">KeyFrameInterpolator</A>&nbsp;k)</PRE>
<DL>
<DD>Sets the KeyFrameInterpolator that defines the Camera path of index <code>key</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addKeyFrameToPath(int)"><!-- --></A><H3>
addKeyFrameToPath</H3>
<PRE>
public void <B>addKeyFrameToPath</B>(int&nbsp;key)</PRE>
<DL>
<DD>Convenience function that simply calls <code>addKeyFrameToPath(key, true)</code>
 .
 <p>
 The resulting created camera path will be editable.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#addKeyFrameToPath(int, boolean)"><CODE>addKeyFrameToPath(int, boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addKeyFrameToPath(int, boolean)"><!-- --></A><H3>
addKeyFrameToPath</H3>
<PRE>
public void <B>addKeyFrameToPath</B>(int&nbsp;key,
                              boolean&nbsp;editablePath)</PRE>
<DL>
<DD>Adds the current Camera <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A> as a
 keyFrame to path <code>key</code>. If <code>editablePath</code> is <code>true</code>,
 builds an InteractiveFrame (from the current Camera <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A> and
 <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A>) before adding it (see
 <A HREF="../../remixlab/proscene/InteractiveFrame.html#InteractiveFrame(remixlab.proscene.Scene, remixlab.proscene.InteractiveCameraFrame)"><CODE>InteractiveFrame.InteractiveFrame(Scene, InteractiveCameraFrame)</CODE></A>
 ). In the latter mode the resulting created path will be editable.
 <p>
 This method can also be used if you simply want to save a Camera point of
 view (a path made of a single keyFrame). Use <A HREF="../../remixlab/proscene/Camera.html#playPath(int)"><CODE>playPath(int)</CODE></A> to make
 the Camera play the keyFrame path (resp. restore the point of view). Use
 <A HREF="../../remixlab/proscene/Camera.html#deletePath(int)"><CODE>deletePath(int)</CODE></A> to clear the path.
 <p>
 The default keyboard shortcuts for this method are keys [1-5].
 <p>
 If you use directly this method and the <A HREF="../../remixlab/proscene/Camera.html#keyFrameInterpolator(int)"><CODE>keyFrameInterpolator(int)</CODE></A>
 does not exist, a new one is created.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="playPath(int)"><!-- --></A><H3>
playPath</H3>
<PRE>
public void <B>playPath</B>(int&nbsp;key)</PRE>
<DL>
<DD>Makes the Camera follow the path of keyFrameInterpolator() number <code>key</code>.
 <p>
 If the interpolation is started, it stops it instead.
 <p>
 This method silently ignores undefined (empty) paths (see
 keyFrameInterpolator()).
 <p>
 The default keyboard shortcuts for this method are keys [1-5].
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="deletePath(int)"><!-- --></A><H3>
deletePath</H3>
<PRE>
public void <B>deletePath</B>(int&nbsp;key)</PRE>
<DL>
<DD>Deletes the <A HREF="../../remixlab/proscene/Camera.html#keyFrameInterpolator(int)"><CODE>keyFrameInterpolator(int)</CODE></A> of index <code>key</code>.
 <p>
 Check <A HREF="../../remixlab/proscene/Scene.html#setDefaultShortcuts()"><CODE>Scene.setDefaultShortcuts()</CODE></A> to see the
 default KeyFrameInterpolators keyboard shortcuts.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="resetPath(int)"><!-- --></A><H3>
resetPath</H3>
<PRE>
public void <B>resetPath</B>(int&nbsp;key)</PRE>
<DL>
<DD>Resets the path of the <A HREF="../../remixlab/proscene/Camera.html#keyFrameInterpolator(int)"><CODE>keyFrameInterpolator(int)</CODE></A> number <code>key</code>.
 <p>
 If this path is not being played (see <A HREF="../../remixlab/proscene/Camera.html#playPath(int)"><CODE>playPath(int)</CODE></A> and
 <A HREF="../../remixlab/proscene/KeyFrameInterpolator.html#interpolationIsStarted()"><CODE>KeyFrameInterpolator.interpolationIsStarted()</CODE></A>),
 resets it to its starting position (see
 <A HREF="../../remixlab/proscene/KeyFrameInterpolator.html#resetInterpolation()"><CODE>KeyFrameInterpolator.resetInterpolation()</CODE></A>). If
 the path is played, simply stops interpolation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawAllPaths()"><!-- --></A><H3>
drawAllPaths</H3>
<PRE>
public void <B>drawAllPaths</B>()</PRE>
<DL>
<DD>Draws all the Camera paths defined by <A HREF="../../remixlab/proscene/Camera.html#keyFrameInterpolator(int)"><CODE>keyFrameInterpolator(int)</CODE></A>
 and makes them editable by adding all its Frames to the mouse grabber pool.
 <p>
 First calls
 <A HREF="../../remixlab/proscene/KeyFrameInterpolator.html#addFramesToMouseGrabberPool()"><CODE>KeyFrameInterpolator.addFramesToMouseGrabberPool()</CODE></A>
 and then
 <A HREF="../../remixlab/proscene/KeyFrameInterpolator.html#drawPath(int, int, float)"><CODE>KeyFrameInterpolator.drawPath(int, int, float)</CODE></A>
 for all the defined paths.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#hideAllPaths()"><CODE>hideAllPaths()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hideAllPaths()"><!-- --></A><H3>
hideAllPaths</H3>
<PRE>
public void <B>hideAllPaths</B>()</PRE>
<DL>
<DD>Hides all the Camera paths defined by <A HREF="../../remixlab/proscene/Camera.html#keyFrameInterpolator(int)"><CODE>keyFrameInterpolator(int)</CODE></A> by
 provisionally removing all its Frames from the mouse grabber pool.
 <p>
 Simply calls
 <A HREF="../../remixlab/proscene/KeyFrameInterpolator.html#removeFramesFromMouseGrabberPool()"><CODE>KeyFrameInterpolator.removeFramesFromMouseGrabberPool()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#drawAllPaths()"><CODE>drawAllPaths()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getProjectionMatrix()"><!-- --></A><H3>
getProjectionMatrix</H3>
<PRE>
public PMatrix3D <B>getProjectionMatrix</B>()</PRE>
<DL>
<DD>Convenience function that simply returns <code>getProjectionMatrix(new
 PMatrix3D())</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#getProjectionMatrix(PMatrix3D)"><CODE>getProjectionMatrix(PMatrix3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getProjectionMatrix(PMatrix3D)"><!-- --></A><H3>
getProjectionMatrix</H3>
<PRE>
public PMatrix3D <B>getProjectionMatrix</B>(PMatrix3D&nbsp;m)</PRE>
<DL>
<DD>Fills <code>m</code> with the Camera projection matrix values and returns it. If
 <code>m</code> is <code>null</code> a new PMatrix3D will be created.
 <p>
 First calls <A HREF="../../remixlab/proscene/Camera.html#computeProjectionMatrix()"><CODE>computeProjectionMatrix()</CODE></A> to define the Camera
 projection matrix.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#getModelViewMatrix()"><CODE>getModelViewMatrix()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="computeProjectionMatrix()"><!-- --></A><H3>
computeProjectionMatrix</H3>
<PRE>
public void <B>computeProjectionMatrix</B>()</PRE>
<DL>
<DD>Computes the projection matrix associated with the Camera.
 <p>
 If <A HREF="../../remixlab/proscene/Camera.html#type()"><CODE>type()</CODE></A> is PERSPECTIVE, defines a projection matrix similar to
 what would <code>perspective()</code> do using the <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A>,
 window <A HREF="../../remixlab/proscene/Camera.html#aspectRatio()"><CODE>aspectRatio()</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A>
 parameters.
 <p>
 If <A HREF="../../remixlab/proscene/Camera.html#type()"><CODE>type()</CODE></A> is ORTHOGRAPHIC, the projection matrix is as what
 <code>ortho()</code> would do. Frustum's width and height are set using
 <A HREF="../../remixlab/proscene/Camera.html#getOrthoWidthHeight()"><CODE>getOrthoWidthHeight()</CODE></A>.
 <p>
 Both types use <A HREF="../../remixlab/proscene/Camera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#zFar()"><CODE>zFar()</CODE></A> to place clipping
 planes. These values are determined from sceneRadius() and sceneCenter() so
 that they best fit the scene size.
 <p>
 Use <A HREF="../../remixlab/proscene/Camera.html#getProjectionMatrix()"><CODE>getProjectionMatrix()</CODE></A> to retrieve this matrix.
 <p>
 <b>Note:</b> You must call this method if your Camera is not associated
 with a Scene and is used for offscreen computations (using <code>projectedCoordinatesOf()</code> for instance).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#setProjectionMatrix(PMatrix3D)"><CODE>setProjectionMatrix(PMatrix3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setProjectionMatrix(PMatrix3D)"><!-- --></A><H3>
setProjectionMatrix</H3>
<PRE>
public void <B>setProjectionMatrix</B>(PMatrix3D&nbsp;proj)</PRE>
<DL>
<DD>Fills the projection matrix with the <code>proj</code> matrix values.
 <p>
 Only meaningful when the camera <A HREF="../../remixlab/proscene/Camera.html#isDetachedFromP5Camera()"><CODE>isDetachedFromP5Camera()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#setModelViewMatrix(PMatrix3D)"><CODE>setModelViewMatrix(PMatrix3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getModelViewMatrix()"><!-- --></A><H3>
getModelViewMatrix</H3>
<PRE>
public PMatrix3D <B>getModelViewMatrix</B>()</PRE>
<DL>
<DD>Convenience function that simply returns <code>getModelViewMatrix(new
 PMatrix3D())</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getModelViewMatrix(PMatrix3D)"><!-- --></A><H3>
getModelViewMatrix</H3>
<PRE>
public PMatrix3D <B>getModelViewMatrix</B>(PMatrix3D&nbsp;m)</PRE>
<DL>
<DD>Fills <code>m</code> with the Camera modelView matrix values and returns it. If
 <code>m</code> is <code>null</code> a new PMatrix3D will be created.
 <p>
 First calls <A HREF="../../remixlab/proscene/Camera.html#computeModelViewMatrix()"><CODE>computeModelViewMatrix()</CODE></A> to define the Camera
 modelView matrix.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#getProjectionMatrix(PMatrix3D)"><CODE>getProjectionMatrix(PMatrix3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="computeModelViewMatrix()"><!-- --></A><H3>
computeModelViewMatrix</H3>
<PRE>
public void <B>computeModelViewMatrix</B>()</PRE>
<DL>
<DD>Computes the modelView matrix associated with the Camera's
 <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A>.
 <p>
 This matrix converts from the world coordinates system to the Camera
 coordinates system, so that coordinates can then be projected on screen
 using the projection matrix (see <A HREF="../../remixlab/proscene/Camera.html#computeProjectionMatrix()"><CODE>computeProjectionMatrix()</CODE></A>).
 <p>
 Use <A HREF="../../remixlab/proscene/Camera.html#getModelViewMatrix()"><CODE>getModelViewMatrix()</CODE></A> to retrieve this matrix.
 <p>
 <b>Note:</b> You must call this method if your Camera is not associated
 with a Scene and is used for offscreen computations (using <code>projectedCoordinatesOf()</code> for instance).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setModelViewMatrix(PMatrix3D)"><!-- --></A><H3>
setModelViewMatrix</H3>
<PRE>
public void <B>setModelViewMatrix</B>(PMatrix3D&nbsp;modelview)</PRE>
<DL>
<DD>Fills the modelview matrix with the <code>modelview</code> matrix values.
 <p>
 Only meaningful when the camera <A HREF="../../remixlab/proscene/Camera.html#isDetachedFromP5Camera()"><CODE>isDetachedFromP5Camera()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#setProjectionMatrix(PMatrix3D)"><CODE>setProjectionMatrix(PMatrix3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cameraCoordinatesOf(PVector)"><!-- --></A><H3>
cameraCoordinatesOf</H3>
<PRE>
public final PVector <B>cameraCoordinatesOf</B>(PVector&nbsp;src)</PRE>
<DL>
<DD>Returns the Camera frame coordinates of a point <code>src</code> defined in
 world coordinates.
 <p>
 <A HREF="../../remixlab/proscene/Camera.html#worldCoordinatesOf(PVector)"><CODE>worldCoordinatesOf(PVector)</CODE></A> performs the inverse transformation.
 <p>
 Note that the point coordinates are simply converted in a different
 coordinate system. They are not projected on screen. Use
 <A HREF="../../remixlab/proscene/Camera.html#projectedCoordinatesOf(PVector, remixlab.proscene.Frame)"><CODE>projectedCoordinatesOf(PVector, Frame)</CODE></A> for that.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="worldCoordinatesOf(PVector)"><!-- --></A><H3>
worldCoordinatesOf</H3>
<PRE>
public PVector <B>worldCoordinatesOf</B>(PVector&nbsp;src)</PRE>
<DL>
<DD>Returns the world coordinates of the point whose position <code>src</code> is
 defined in the Camera coordinate system.
 <p>
 <A HREF="../../remixlab/proscene/Camera.html#cameraCoordinatesOf(PVector)"><CODE>cameraCoordinatesOf(PVector)</CODE></A> performs the inverse transformation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="convertClickToLine(remixlab.proscene.Point, PVector, PVector)"><!-- --></A><H3>
convertClickToLine</H3>
<PRE>
public void <B>convertClickToLine</B>(<A HREF="../../remixlab/proscene/Point.html" title="class in remixlab.proscene">Point</A>&nbsp;pixelInput,
                               PVector&nbsp;orig,
                               PVector&nbsp;dir)</PRE>
<DL>
<DD>Gives the coefficients of a 3D half-line passing through the Camera eye and
 pixel (x,y).
 <p>
 The origin of the half line (eye position) is stored in <code>orig</code>, while
 <code>dir</code> contains the properly oriented and normalized direction of the
 half line.
 <p>
 <code>x</code> and <code>y</code> are expressed in Processing format (origin in the
 upper left corner). Use <A HREF="../../remixlab/proscene/Camera.html#screenHeight()"><CODE>screenHeight()</CODE></A> - y to convert to
 processing scene units.
 <p>
 This method is useful for analytical intersection in a selection method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="projectedCoordinatesOf(PVector)"><!-- --></A><H3>
projectedCoordinatesOf</H3>
<PRE>
public final PVector <B>projectedCoordinatesOf</B>(PVector&nbsp;src)</PRE>
<DL>
<DD>Convenience function that simply returns <code>projectedCoordinatesOf(src,
 null)</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#projectedCoordinatesOf(PVector, remixlab.proscene.Frame)"><CODE>projectedCoordinatesOf(PVector, Frame)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="projectedCoordinatesOf(PVector, remixlab.proscene.Frame)"><!-- --></A><H3>
projectedCoordinatesOf</H3>
<PRE>
public final PVector <B>projectedCoordinatesOf</B>(PVector&nbsp;src,
                                            <A HREF="../../remixlab/proscene/Frame.html" title="class in remixlab.proscene">Frame</A>&nbsp;frame)</PRE>
<DL>
<DD>Returns the screen projected coordinates of a point <code>src</code> defined in
 the <code>frame</code> coordinate system.
 <p>
 When <code>frame</code> is <code>null</code>, <code>src</code> is expressed in the world
 coordinate system. See <A HREF="../../remixlab/proscene/Camera.html#projectedCoordinatesOf(PVector)"><CODE>projectedCoordinatesOf(PVector)</CODE></A>.
 <p>
 The x and y coordinates of the returned PVector are expressed in pixel,
 (0,0) being the upper left corner of the window. The z coordinate ranges
 between 0.0 (near plane) and 1.0 (excluded, far plane). See the <code>gluProject</code> man page for details.
 <p>
 <b>Attention:</b> This method only uses the intrinsic Camera parameters
 (see <A HREF="../../remixlab/proscene/Camera.html#getModelViewMatrix()"><CODE>getModelViewMatrix()</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#getProjectionMatrix()"><CODE>getProjectionMatrix()</CODE></A> and
 <A HREF="../../remixlab/proscene/Camera.html#getViewport()"><CODE>getViewport()</CODE></A>) and is completely independent of the processing
 matrices. You can hence define a virtual Camera and use this method to
 compute projections out of a classical rendering context.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#unprojectedCoordinatesOf(PVector, remixlab.proscene.Frame)"><CODE>unprojectedCoordinatesOf(PVector, Frame)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="unprojectedCoordinatesOf(PVector)"><!-- --></A><H3>
unprojectedCoordinatesOf</H3>
<PRE>
public final PVector <B>unprojectedCoordinatesOf</B>(PVector&nbsp;src)</PRE>
<DL>
<DD>Convenience function that simply returns <code>return
 unprojectedCoordinatesOf(src, null)</code>
 
 #see <A HREF="../../remixlab/proscene/Camera.html#unprojectedCoordinatesOf(PVector, remixlab.proscene.Frame)"><CODE>unprojectedCoordinatesOf(PVector, Frame)</CODE></A>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="unprojectedCoordinatesOf(PVector, remixlab.proscene.Frame)"><!-- --></A><H3>
unprojectedCoordinatesOf</H3>
<PRE>
public final PVector <B>unprojectedCoordinatesOf</B>(PVector&nbsp;src,
                                              <A HREF="../../remixlab/proscene/Frame.html" title="class in remixlab.proscene">Frame</A>&nbsp;frame)</PRE>
<DL>
<DD>Returns the world unprojected coordinates of a point <code>src</code> defined in
 the screen coordinate system.
 <p>
 The <code>src.x</code> and <code>src.y</code> input values are expressed in pixels,
 (0,0) being the upper left corner of the window. <code>src.z</code> is a depth
 value ranging in [0..1] (near and far plane respectively). See the <code>gluUnProject</code> man page for details.
 <p>
 The result is expressed in the <code>frame</code> coordinate system. When
 <code>frame</code> is <code>null</code>, the result is expressed in the world
 coordinates system. The possible <code>frame</code>
 <A HREF="../../remixlab/proscene/Frame.html#referenceFrame()"><CODE>Frame.referenceFrame()</CODE></A> are taken into account.
 <p>
 <A HREF="../../remixlab/proscene/Camera.html#projectedCoordinatesOf(PVector, remixlab.proscene.Frame)"><CODE>projectedCoordinatesOf(PVector, Frame)</CODE></A> performs the inverse
 transformation.
 <p>
 This method only uses the intrinsic Camera parameters (see
 <A HREF="../../remixlab/proscene/Camera.html#getModelViewMatrix()"><CODE>getModelViewMatrix()</CODE></A>, <A HREF="../../remixlab/proscene/Camera.html#getProjectionMatrix()"><CODE>getProjectionMatrix()</CODE></A> and
 <A HREF="../../remixlab/proscene/Camera.html#getViewport()"><CODE>getViewport()</CODE></A>) and is completely independent of the Processing
 matrices. You can hence define a virtual Camera and use this method to
 compute un-projections out of a classical rendering context.
 <p>
 <b>Attention:</b> However, if your Camera is not attached to a Scene (used
 for offscreen computations for instance), make sure the Camera matrices are
 updated before calling this method (use <A HREF="../../remixlab/proscene/Camera.html#computeModelViewMatrix()"><CODE>computeModelViewMatrix()</CODE></A>,
 <A HREF="../../remixlab/proscene/Camera.html#computeProjectionMatrix()"><CODE>computeProjectionMatrix()</CODE></A>).
 <p>
 This method is not computationally optimized. If you call it several times
 with no change in the matrices, you should buffer the entire inverse
 projection matrix (modelview, projection and then viewport) to speed-up the
 queries. See the gluUnProject man page for details.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#projectedCoordinatesOf(PVector, remixlab.proscene.Frame)"><CODE>projectedCoordinatesOf(PVector, Frame)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#setScreenWidthAndHeight(int, int)"><CODE>setScreenWidthAndHeight(int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="flySpeed()"><!-- --></A><H3>
flySpeed</H3>
<PRE>
public float <B>flySpeed</B>()</PRE>
<DL>
<DD>Returns the fly speed of the Camera.
 <p>
 Simply returns <code>frame().flySpeed()</code>. See the
 <A HREF="../../remixlab/proscene/InteractiveDrivableFrame.html#flySpeed()"><CODE>InteractiveDrivableFrame.flySpeed()</CODE></A> documentation.
 This value is only meaningful when the MouseAction bindings is
 Scene.MOVE_FORWARD or is Scene.MOVE_BACKWARD.
 <p>
 Set to 0.5% of the <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> by <A HREF="../../remixlab/proscene/Camera.html#setSceneRadius(float)"><CODE>setSceneRadius(float)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#setFlySpeed(float)"><CODE>setFlySpeed(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFlySpeed(float)"><!-- --></A><H3>
setFlySpeed</H3>
<PRE>
public void <B>setFlySpeed</B>(float&nbsp;speed)</PRE>
<DL>
<DD>Sets the Camera <A HREF="../../remixlab/proscene/Camera.html#flySpeed()"><CODE>flySpeed()</CODE></A>.
 <p>
 <b>Attention:</b> This value is modified by <A HREF="../../remixlab/proscene/Camera.html#setSceneRadius(float)"><CODE>setSceneRadius(float)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lookAt(PVector)"><!-- --></A><H3>
lookAt</H3>
<PRE>
public void <B>lookAt</B>(PVector&nbsp;target)</PRE>
<DL>
<DD>Sets the Camera <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A>, so that it looks at point <code>target</code> (defined in the world coordinate system).
 <p>
 The Camera <A HREF="../../remixlab/proscene/Camera.html#position()"><CODE>position()</CODE></A> is not modified. Simply
 <A HREF="../../remixlab/proscene/Camera.html#setViewDirection(PVector)"><CODE>setViewDirection(PVector)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#at()"><CODE>at()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#setUpVector(PVector)"><CODE>setUpVector(PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#setOrientation(remixlab.proscene.Quaternion)"><CODE>setOrientation(Quaternion)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#fitSphere(PVector, float)"><CODE>fitSphere(PVector, float)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#fitBoundingBox(PVector, PVector)"><CODE>fitBoundingBox(PVector, PVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="at()"><!-- --></A><H3>
at</H3>
<PRE>
public PVector <B>at</B>()</PRE>
<DL>
<DD>Returns a point defined in the world coordinate system where the camera is
 pointing at (just in front of <A HREF="../../remixlab/proscene/Camera.html#viewDirection()"><CODE>viewDirection()</CODE></A>). Useful for setting
 the Processing camera() which uses a similar approach of that found in
 gluLookAt.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#lookAt(PVector)"><CODE>lookAt(PVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="fitSphere(PVector, float)"><!-- --></A><H3>
fitSphere</H3>
<PRE>
public void <B>fitSphere</B>(PVector&nbsp;center,
                      float&nbsp;radius)</PRE>
<DL>
<DD>Moves the Camera so that the sphere defined by <code>center</code> and <code>radius</code> is visible and fits the window.
 <p>
 The Camera is simply translated along its <A HREF="../../remixlab/proscene/Camera.html#viewDirection()"><CODE>viewDirection()</CODE></A> so that
 the sphere fits the screen. Its <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A> and its
 <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> are unchanged.
 <p>
 You should therefore orientate the Camera before you call this method.
 <p>
 <b>Attention:</b> If the Camera <A HREF="../../remixlab/proscene/Camera.html#kind()"><CODE>kind()</CODE></A> is STANDARD, simply resets
 the <A HREF="../../remixlab/proscene/Camera.html#standardOrthoFrustumSize()"><CODE>standardOrthoFrustumSize()</CODE></A> to 1 and then calls <code>lookAt(sceneCenter())</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#lookAt(PVector)"><CODE>lookAt(PVector)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#setOrientation(remixlab.proscene.Quaternion)"><CODE>setOrientation(Quaternion)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#setUpVector(PVector, boolean)"><CODE>setUpVector(PVector, boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="fitBoundingBox(PVector, PVector)"><!-- --></A><H3>
fitBoundingBox</H3>
<PRE>
public void <B>fitBoundingBox</B>(PVector&nbsp;min,
                           PVector&nbsp;max)</PRE>
<DL>
<DD>Moves the Camera so that the (world axis aligned) bounding box (<code>min</code>
 , <code>max</code>) is entirely visible, using
 <A HREF="../../remixlab/proscene/Camera.html#fitSphere(PVector, float)"><CODE>fitSphere(PVector, float)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="fitScreenRegion(remixlab.proscene.Rectangle)"><!-- --></A><H3>
fitScreenRegion</H3>
<PRE>
public void <B>fitScreenRegion</B>(<A HREF="../../remixlab/proscene/Rectangle.html" title="class in remixlab.proscene">Rectangle</A>&nbsp;rectangle)</PRE>
<DL>
<DD>Moves the Camera so that the rectangular screen region defined by <code>rectangle</code> (pixel units, with origin in the upper left corner) fits the
 screen.
 <p>
 The Camera is translated (its <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A> is unchanged) so that
 <code>rectangle</code> is entirely visible. Since the pixel coordinates only
 define a <i>frustum</i> in 3D, it's the intersection of this frustum with a
 plane (orthogonal to the <A HREF="../../remixlab/proscene/Camera.html#viewDirection()"><CODE>viewDirection()</CODE></A> and passing through the
 <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>) that is used to define the 3D rectangle that is
 eventually fitted.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="showEntireScene()"><!-- --></A><H3>
showEntireScene</H3>
<PRE>
public void <B>showEntireScene</B>()</PRE>
<DL>
<DD>Moves the Camera so that the entire scene is visible.
 <p>
 Simply calls <A HREF="../../remixlab/proscene/Camera.html#fitSphere(PVector, float)"><CODE>fitSphere(PVector, float)</CODE></A> on a sphere defined by
 <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A>.
 <p>
 You will typically use this method in
 <A HREF="../../remixlab/proscene/Scene.html#init()"><CODE>Scene.init()</CODE></A> after you defined a new
 <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="centerScene()"><!-- --></A><H3>
centerScene</H3>
<PRE>
public void <B>centerScene</B>()</PRE>
<DL>
<DD>Moves the Camera so that its <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> is projected on the
 center of the window. The <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A> and <A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A>
 are unchanged.
 <p>
 Simply projects the current position on a line passing through
 <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="interpolateToZoomOnRegion(remixlab.proscene.Rectangle)"><!-- --></A><H3>
interpolateToZoomOnRegion</H3>
<PRE>
public void <B>interpolateToZoomOnRegion</B>(<A HREF="../../remixlab/proscene/Rectangle.html" title="class in remixlab.proscene">Rectangle</A>&nbsp;rectangle)</PRE>
<DL>
<DD>Smoothly moves the Camera so that the rectangular screen region defined by
 <code>rectangle</code> (pixel units, with origin in the upper left corner) fits
 the screen.
 <p>
 The Camera is translated (its <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A> is unchanged) so that
 <code>rectangle</code> is entirely visible. Since the pixel coordinates only
 define a <i>frustum</i> in 3D, it's the intersection of this frustum with a
 plane (orthogonal to the <A HREF="../../remixlab/proscene/Camera.html#viewDirection()"><CODE>viewDirection()</CODE></A> and passing through the
 <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>) that is used to define the 3D rectangle that is
 eventually fitted.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#fitScreenRegion(remixlab.proscene.Rectangle)"><CODE>fitScreenRegion(Rectangle)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="interpolateToZoomOnPixel(remixlab.proscene.Point)"><!-- --></A><H3>
interpolateToZoomOnPixel</H3>
<PRE>
public <A HREF="../../remixlab/proscene/Camera.WorldPoint.html" title="class in remixlab.proscene">Camera.WorldPoint</A> <B>interpolateToZoomOnPixel</B>(<A HREF="../../remixlab/proscene/Point.html" title="class in remixlab.proscene">Point</A>&nbsp;pixel)</PRE>
<DL>
<DD>Makes the Camera smoothly zoom on the <A HREF="../../remixlab/proscene/Camera.html#pointUnderPixel(remixlab.proscene.Point)"><CODE>pointUnderPixel(Point)</CODE></A>
 <code>pixel</code> and returns the world coordinates of the
 <A HREF="../../remixlab/proscene/Camera.html#pointUnderPixel(remixlab.proscene.Point)"><CODE>pointUnderPixel(Point)</CODE></A>.
 <p>
 Nothing happens if no <A HREF="../../remixlab/proscene/Camera.html#pointUnderPixel(remixlab.proscene.Point)"><CODE>pointUnderPixel(Point)</CODE></A> is found. Otherwise a
 KeyFrameInterpolator is created that animates the Camera on a one second
 path that brings the Camera closer to the point under <code>pixel</code>.
 <p>
 <b>Attention:</b> Override this method in your jogl-based camera class. See
 <A HREF="../../remixlab/proscene/Camera.html#pointUnderPixel(remixlab.proscene.Point)"><CODE>pointUnderPixel(Point)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#interpolateToFitScene()"><CODE>interpolateToFitScene()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="interpolateToFitScene()"><!-- --></A><H3>
interpolateToFitScene</H3>
<PRE>
public void <B>interpolateToFitScene</B>()</PRE>
<DL>
<DD>Interpolates the Camera on a one second KeyFrameInterpolator path so that
 the entire scene fits the screen at the end.
 <p>
 The scene is defined by its <A HREF="../../remixlab/proscene/Camera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> and its
 <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A>. See <A HREF="../../remixlab/proscene/Camera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A>.
 <p>
 The <A HREF="../../remixlab/proscene/Camera.html#orientation()"><CODE>orientation()</CODE></A> of the Camera is not modified.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#interpolateToZoomOnPixel(remixlab.proscene.Point)"><CODE>interpolateToZoomOnPixel(Point)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="interpolateTo(remixlab.proscene.Frame)"><!-- --></A><H3>
interpolateTo</H3>
<PRE>
public void <B>interpolateTo</B>(<A HREF="../../remixlab/proscene/Frame.html" title="class in remixlab.proscene">Frame</A>&nbsp;fr)</PRE>
<DL>
<DD>Convenience function that simply calls <code>interpolateTo(fr, 1)</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#interpolateTo(remixlab.proscene.Frame, float)"><CODE>interpolateTo(Frame, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="interpolateTo(remixlab.proscene.Frame, float)"><!-- --></A><H3>
interpolateTo</H3>
<PRE>
public void <B>interpolateTo</B>(<A HREF="../../remixlab/proscene/Frame.html" title="class in remixlab.proscene">Frame</A>&nbsp;fr,
                          float&nbsp;duration)</PRE>
<DL>
<DD>Smoothly interpolates the Camera on a KeyFrameInterpolator path so that it
 goes to <code>fr</code>.
 <p>
 <code>fr</code> is expressed in world coordinates. <code>duration</code> tunes the
 interpolation speed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#interpolateTo(remixlab.proscene.Frame)"><CODE>interpolateTo(Frame)</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#interpolateToFitScene()"><CODE>interpolateToFitScene()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#interpolateToZoomOnPixel(remixlab.proscene.Point)"><CODE>interpolateToZoomOnPixel(Point)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="anyInterpolationIsStarted()"><!-- --></A><H3>
anyInterpolationIsStarted</H3>
<PRE>
public boolean <B>anyInterpolationIsStarted</B>()</PRE>
<DL>
<DD>Returns <code>true</code> if any interpolation associated with this Camera
 is currently being performed (and <code>false</code> otherwise).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="stopAllInterpolations()"><!-- --></A><H3>
stopAllInterpolations</H3>
<PRE>
public void <B>stopAllInterpolations</B>()</PRE>
<DL>
<DD>Stops all interpolations currently being performed
 associated with this Camera.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="IODistance()"><!-- --></A><H3>
IODistance</H3>
<PRE>
public float <B>IODistance</B>()</PRE>
<DL>
<DD>Returns the user's inter-ocular distance (in meters). Default value is
 0.062m, which fits most people.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#setIODistance(float)"><CODE>setIODistance(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setIODistance(float)"><!-- --></A><H3>
setIODistance</H3>
<PRE>
public void <B>setIODistance</B>(float&nbsp;distance)</PRE>
<DL>
<DD>Sets the <A HREF="../../remixlab/proscene/Camera.html#IODistance()"><CODE>IODistance()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="physicalDistanceToScreen()"><!-- --></A><H3>
physicalDistanceToScreen</H3>
<PRE>
public float <B>physicalDistanceToScreen</B>()</PRE>
<DL>
<DD>Returns the physical distance between the user's eyes and the screen (in
 meters).
 <p>
 Default value is 0.5m.
 <p>
 Value is set using <A HREF="../../remixlab/proscene/Camera.html#setPhysicalDistanceToScreen(float)"><CODE>setPhysicalDistanceToScreen(float)</CODE></A>.
 <p>
 physicalDistanceToScreen() and <A HREF="../../remixlab/proscene/Camera.html#focusDistance()"><CODE>focusDistance()</CODE></A> represent the same
 distance. The first one is expressed in physical real world units, while
 the latter is expressed in processing virtual world units. Use their ratio
 to convert distances between these worlds.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setPhysicalDistanceToScreen(float)"><!-- --></A><H3>
setPhysicalDistanceToScreen</H3>
<PRE>
public void <B>setPhysicalDistanceToScreen</B>(float&nbsp;distance)</PRE>
<DL>
<DD>Sets the <A HREF="../../remixlab/proscene/Camera.html#physicalDistanceToScreen()"><CODE>physicalDistanceToScreen()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="physicalScreenWidth()"><!-- --></A><H3>
physicalScreenWidth</H3>
<PRE>
public float <B>physicalScreenWidth</B>()</PRE>
<DL>
<DD>Returns the physical screen width, in meters. Default value is 0.4m
 (average monitor).
 <p>
 Used for stereo display only. Set using
 <A HREF="../../remixlab/proscene/Camera.html#setPhysicalScreenWidth(float)"><CODE>setPhysicalScreenWidth(float)</CODE></A>.
 <p>
 See <A HREF="../../remixlab/proscene/Camera.html#physicalDistanceToScreen()"><CODE>physicalDistanceToScreen()</CODE></A> for reality center automatic
 configuration.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setPhysicalScreenWidth(float)"><!-- --></A><H3>
setPhysicalScreenWidth</H3>
<PRE>
public void <B>setPhysicalScreenWidth</B>(float&nbsp;width)</PRE>
<DL>
<DD>Sets the physical screen (monitor or projected wall) width (in meters).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="focusDistance()"><!-- --></A><H3>
focusDistance</H3>
<PRE>
public float <B>focusDistance</B>()</PRE>
<DL>
<DD>Returns the focus distance used by stereo display, expressed in processing
 units.
 <p>
 This is the distance in the virtual world between the Camera and the plane
 where the horizontal stereo parallax is null (the stereo left and right
 images are superimposed).
 <p>
 This distance is the virtual world equivalent of the real-world
 <A HREF="../../remixlab/proscene/Camera.html#physicalDistanceToScreen()"><CODE>physicalDistanceToScreen()</CODE></A>.
 <p>
 <b>attention:</b> This value is modified by Scene.setSceneRadius(),
 setSceneRadius() and <A HREF="../../remixlab/proscene/Camera.html#setFieldOfView(float)"><CODE>setFieldOfView(float)</CODE></A>. When one of these
 values is modified, <A HREF="../../remixlab/proscene/Camera.html#focusDistance()"><CODE>focusDistance()</CODE></A> is set to
 <A HREF="../../remixlab/proscene/Camera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> / tan(<A HREF="../../remixlab/proscene/Camera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A>/2), which provides good
 results.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFocusDistance(float)"><!-- --></A><H3>
setFocusDistance</H3>
<PRE>
public void <B>setFocusDistance</B>(float&nbsp;distance)</PRE>
<DL>
<DD>Sets the focusDistance(), in processing scene units.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cacheMatrices()"><!-- --></A><H3>
cacheMatrices</H3>
<PRE>
protected void <B>cacheMatrices</B>()</PRE>
<DL>
<DD>Cache <code>(P x M)</code> and <code>inv (P x M)</code> under the following circumstances:
 <p>
 i) If <code>scene.mouseGrabberPool().size() &gt; 3 &amp;&amp; scene.hasMouseTracking()</code> then
 <code>(P x M)</code> is cached so that
 <A HREF="../../remixlab/proscene/Camera.html#project(float, float, float, PMatrix3D, PMatrix3D, int[], float[])"><CODE>project(float, float, float, PMatrix3D, PMatrix3D, int[], float[])</CODE></A> is speeded up.
 <p>
 ii) If <A HREF="../../remixlab/proscene/Camera.html#unprojectCacheIsOptimized()"><CODE>unprojectCacheIsOptimized()</CODE></A> <code>inv (P x M)</code> is cached (and hence
 <code>(P x M)</code> is cached too) so that 
 <A HREF="../../remixlab/proscene/Camera.html#unproject(float, float, float, PMatrix3D, PMatrix3D, int[], float[])"><CODE>unproject(float, float, float, PMatrix3D, PMatrix3D, int[], float[])</CODE></A> is speeded up.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#unprojectCacheIsOptimized()"><CODE>unprojectCacheIsOptimized()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#optimizeUnprojectCache(boolean)"><CODE>optimizeUnprojectCache(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="unprojectCacheIsOptimized()"><!-- --></A><H3>
unprojectCacheIsOptimized</H3>
<PRE>
public boolean <B>unprojectCacheIsOptimized</B>()</PRE>
<DL>
<DD>Returns <code>true</code> if <code>P x M</code> and <code>inv (P x M)</code> are being cached,
 and <code>false</code> otherwise.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#cacheMatrices()"><CODE>cacheMatrices()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#optimizeUnprojectCache(boolean)"><CODE>optimizeUnprojectCache(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="optimizeUnprojectCache(boolean)"><!-- --></A><H3>
optimizeUnprojectCache</H3>
<PRE>
public void <B>optimizeUnprojectCache</B>(boolean&nbsp;optimise)</PRE>
<DL>
<DD>Cache <code>inv (P x M)</code> (and also <code>(P x M)</code> ) so that
 <A HREF="../../remixlab/proscene/Camera.html#project(float, float, float, PMatrix3D, PMatrix3D, int[], float[])"><CODE>project(float, float, float, PMatrix3D, PMatrix3D, int[], float[])</CODE></A>
 (and also <A HREF="../../remixlab/proscene/Camera.html#unproject(float, float, float, PMatrix3D, PMatrix3D, int[], float[])"><CODE>unproject(float, float, float, PMatrix3D, PMatrix3D, int[], float[])</CODE></A>)
 is optimised.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../remixlab/proscene/Camera.html#unprojectCacheIsOptimized()"><CODE>unprojectCacheIsOptimized()</CODE></A>, 
<A HREF="../../remixlab/proscene/Camera.html#cacheMatrices()"><CODE>cacheMatrices()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="project(float, float, float, PMatrix3D, PMatrix3D, int[], float[])"><!-- --></A><H3>
project</H3>
<PRE>
public boolean <B>project</B>(float&nbsp;objx,
                       float&nbsp;objy,
                       float&nbsp;objz,
                       PMatrix3D&nbsp;modelview,
                       PMatrix3D&nbsp;projection,
                       int[]&nbsp;viewport,
                       float[]&nbsp;windowCoordinate)</PRE>
<DL>
<DD>Similar to <code>gluProject</code>: map object coordinates to window
 coordinates.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>objx</CODE> - Specify the object x coordinate.<DD><CODE>objy</CODE> - Specify the object y coordinate.<DD><CODE>objz</CODE> - Specify the object z coordinate.<DD><CODE>modelview</CODE> - Specifies the current modelview matrix.<DD><CODE>projection</CODE> - Specifies the current projection matrix.<DD><CODE>viewport</CODE> - Specifies the current viewport.<DD><CODE>windowCoordinate</CODE> - Return the computed window coordinates.</DL>
</DD>
</DL>
<HR>

<A NAME="unproject(float, float, float, PMatrix3D, PMatrix3D, int[], float[])"><!-- --></A><H3>
unproject</H3>
<PRE>
public boolean <B>unproject</B>(float&nbsp;winx,
                         float&nbsp;winy,
                         float&nbsp;winz,
                         PMatrix3D&nbsp;modelview,
                         PMatrix3D&nbsp;projection,
                         int[]&nbsp;viewport,
                         float[]&nbsp;objCoordinate)</PRE>
<DL>
<DD>Similar to <code>gluUnProject</code>: map window coordinates to object
 coordinates.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>winx</CODE> - Specify the window x coordinate.<DD><CODE>winy</CODE> - Specify the window y coordinate.<DD><CODE>winz</CODE> - Specify the window z coordinate.<DD><CODE>modelview</CODE> - Specifies the current modelview matrix.<DD><CODE>projection</CODE> - Specifies the current projection matrix.<DD><CODE>viewport</CODE> - Specifies the current viewport.<DD><CODE>objCoordinate</CODE> - Return the computed object coordinates.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../remixlab/proscene/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../remixlab/proscene/Bindings.html" title="class in remixlab.proscene"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../remixlab/proscene/Camera.Cone.html" title="class in remixlab.proscene"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?remixlab/proscene/Camera.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Camera.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
